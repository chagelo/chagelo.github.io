<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chagelo</title>
  
  
  <link href="https://chagelo.github.io/atom.xml" rel="self"/>
  
  <link href="https://chagelo.github.io/"/>
  <updated>2019-05-21T12:58:15.149Z</updated>
  <id>https://chagelo.github.io/</id>
  
  <author>
    <name>chagelo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://chagelo.github.io/2021/09/03/hello-world/"/>
    <id>https://chagelo.github.io/2021/09/03/hello-world/</id>
    <published>2021-09-03T13:46:47.918Z</published>
    <updated>2019-05-21T12:58:15.149Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;quick-start&quot;&gt;Quick Start&lt;/h2&gt;
&lt;h3 id=&quot;create-a-new-post&quot;&gt;Create a new post&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2021/04/18</title>
    <link href="https://chagelo.github.io/2021/04/18/2021-04-18/"/>
    <id>https://chagelo.github.io/2021/04/18/2021-04-18/</id>
    <published>2021-04-18T08:06:15.000Z</published>
    <updated>2021-04-30T02:03:22.828Z</updated>
    
    <content type="html"><![CDATA[<p>这是一段来自知乎匿名用户的评论：</p><p>我以为黑暗的路上只有我一人，踉踉跄跄。当我燃起微弱希望的一刻，看到了满目的行者。大家相视一笑，继而散作满天星。</p><span id="more"></span><p>山的那边依然是山，而我已经翻过自己心中的山；剩下的那些叠嶂，成了我乐意去欣赏的绝美风景；纵使沟壑万丈，我也会用自己的智慧逢山开路遇水搭桥。</p><p>“恰同学少年”，我想，这就是我梦想中真正理想的自己。强大到连自己都心生敬佩，却不孤芳自赏，更不与人喋喋呓语。</p><p>不再为一点利益纠葛不清；不再痴迷爱情深渊；不再贪恋那些物质虚荣。在知识中“挥斥方遒”，铸造自己的罗马，又为人点亮心灯。</p><p>我之所以变得波澜不惊，是因为我已经在铸造我自己墓志铭的路上，就像我觉得我看伟人的书时候，我甚至能感知到他还有什么没说；这种懂你的激动，甚至没有寄托于任何的身体或者精神的茧房。因为我知道，以后一定有一个人能通过我的文字，读懂我的内心。</p><p>做研究的人，或多或少已经走到人类知识的边界，一边是现实，一边是深渊，我们可能并不清楚我走过去搭上的是桥梁，还是葬身地平线。</p><p>记得英语老师讲过一个故事，柏拉图的洞穴。我想，我一定应该是那个走出洞穴的人。我一直相信梦在远方；后来，我来了很远的地方。</p><p>我现在发现，支撑我的，其实并不是找一个懂我的她；也不是为了改善生活，亦非获得什么荣华富贵。而是，找到了自己。</p><p>我们寻找的榜样，其实就是自己。——致当代的博士研究生</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一段来自知乎匿名用户的评论：&lt;/p&gt;
&lt;p&gt;我以为黑暗的路上只有我一人，踉踉跄跄。当我燃起微弱希望的一刻，看到了满目的行者。大家相视一笑，继而散作满天星。&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://chagelo.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="随笔" scheme="https://chagelo.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>考研备考回忆</title>
    <link href="https://chagelo.github.io/2021/04/14/%E8%80%83%E7%A0%94%E5%A4%87%E8%80%83%E5%9B%9E%E5%BF%86/"/>
    <id>https://chagelo.github.io/2021/04/14/%E8%80%83%E7%A0%94%E5%A4%87%E8%80%83%E5%9B%9E%E5%BF%86/</id>
    <published>2021-04-14T09:39:22.000Z</published>
    <updated>2021-04-30T02:03:12.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备考回忆">备考回忆</h2><p>写这篇博客的目的是为了留给未来的自己一段回忆，曾经也有过为目标而努力奋斗的</p><h3 id="结果">结果</h3><p>2021报考中科大计算机学院，计算机学硕，初试分数：英语（一）64、政治74、专业课（408）115、数学一142，总分395；</p><span id="more"></span><h3 id="自身情况">自身情况</h3><ul><li>本科江苏地区双非，大一石油工程转到计算机，事实上，不同层次学校的教学质量真的差距很大；</li><li>从小到大都挺喜欢数学的，数学也比较擅长，大一刚入学比较有激情，专业第一，数学100、95；后面备考的时候报了个省高数竞赛，拿了个一等奖，我们学校的最好成绩（当时我觉得发挥的蛮好的，所以在整个江苏省应该也能排的比较靠前）；我的数学基础还可以，但我不是那种有天赋的人；</li><li>大二加入了校ACM队，有一定编程基础，但比较菜，丝毫没有项目经验；</li><li>英语是靠着语感学的，英语也很一般，四六级都是飘过；</li></ul><h3 id="关于报考院校">关于报考院校</h3><p>中学的时候一直都想考中科大，但是很贪玩，没有老老实实接受义务教育；现在有了这样一个机会，就考了；考计算机学院的学硕，我觉得挺不简单的，当时择校的时候也在一直犹豫，但是最后是鼓励自己把这当成了一个挑战，然后毅然继续了下去；</p><h3 id="备考过程">备考过程</h3><p>朝七晚12，实验室、寝室、食堂三点一线；</p><h4 id="英语">英语</h4><p>考完对的某机构的答案，发现后面两篇阅读几乎全错了，到出成绩之前，我都做好心理准备二战了，结果还有64分，这个分数我满足了；</p><p>自己是从2月21开始背单词（当时这个时候应该已经在学校了，但是疫情的原因在家上网课），每天晚上10点到12点，用的墨墨，每天60-80个生单词，到6月多结束；第一轮单词结束后，由于期末考试的原因，于是中间有两个星期左右没碰单词，后面又花了一番功夫（单词不能落下）；单词是阅读的基础；之后8月开始做真题，每天两篇，时间比较多的话，推荐读一下外刊；唐迟的阅读课讲的不错；最后两个月需要认真练一下作文，平常做阅读也可以积累积累；</p><p>比较重要的几点就是：</p><ul><li>单词是阅读的基础，不能断</li><li>真题很重要，模拟题没用</li><li>阅读读懂最重要</li></ul><p>但这个过程中比较遗憾的是，我没有对英语非常认真，我清楚自己的水平，因此我英语只想拿一个一般的分数；但是我越来越发现英语很重要，不然我的英语水平应该会有一个较大提升，这里说的不是英语考试的能力；</p><h4 id="政治">政治</h4><p>自己的政治是从10月份左右开始的，先看的徐涛的网课；一开始zzh、hcw、cth先我开始的政治，他们看的徐涛的网课，自己也去试着听了，发现这个老师贼有趣；</p><p>9月份开始应该还可以，10月份有点晚；网课看完都11月了，然后就去刷肖秀荣的《1000题》，不会的就去看课本，《1000题》最后没刷完，刷了个大部分，然后买了个徐涛的小黄书，这是一本总结性的书，还是蛮好的，这本书也看了几遍；12月开始就去刷模拟题的选择题了，市面上的模拟题很多，刷完一套总结一套，我是把自己不知道的知识都记了note，徐涛的公众也会发知识点的总结，还有一些总结的“帽子”，当时我们几个（mfx、zzh、hcw、cth还有我）互相提问；</p><p>刚开始刷模拟题的时候，选择题老是30分，按这个分数估自己的总分发现不可能上70，慌的不得了，就去看书，复习自己做的笔记，考前10天的时候，刷了肖秀荣的，分数也慢慢的好了起来了（肖秀荣的八套、四套刷了两遍）；记得自己当时很认真的看政治，最后政治选择题38分，虽然考试的选择很简单，但我挺满意的了；</p><p>分析题就是背肖秀荣的四套，也可以选择徐涛的20题，考前10天就可以开始背了；</p><p>（然而没有很认真的hcw，只比我低了两分，可能政治真的不需要怎么复习？）</p><p><strong>对徐涛这个老师印象最深刻的就是他对<a href="https://www.youtube.com/watch?v=IUuGnALTJPE&amp;list=PLRMOX8QaZK8wYHSTn0OmjvQqzZsUug-Gu&amp;index=34">“服务人民，奉献社会”</a>的理解</strong></p><h4 id="专业课">专业课</h4><p>专业课的分数是最不满意的，算法题太简单了，甚至在题目直接告诉了答案，导致我读错题，然后导致算法题15分自然无了，wtf；</p><p>大概4月份开始看计组，看了一遍王道书，然后又看了一遍课本，5月20多开学，开始os，大概到8月份，专业课一轮结束，到9月10号看了第二轮的王道书，但是看完依然觉得学的不够好，后面就反复的不断的看王道书（最后估计有6、7遍），好像10月才开始真题；直到考试前，依然觉得自己os学的不够好，主要是因为os太抽象了，尤其I/O那块（历史遗留问题的原因，太琐碎了），如果回去，一定会去具体的接触一下内核，这样才会有更深刻的理解；</p><p>我的感受就是，书上说的太空虚了；其实如果能够实践与理论结合一下就会有更加完善深刻的理解与认知；比如对于计算机网络，就可以捣鼓捣鼓路由器，做做自顶向下的实验，os的话就可以动手实现下简单的内核；对于数据结构的话，由于有算法竞赛的基础，自然不成问题了；</p><p><strong>推荐</strong>：王道四本书，《自顶向下》，《linux内核设计与实现》，《操作系统》《（西电的）</p><h4 id="数学">数学</h4><p>数学是自己擅长的学科，花费了很多精力，最终也确实拿到了满意的分数；</p><p>2月21开始复习数学，到4月份把李正元复习全书的高数部分过了一遍，例题也要做，同时一遍写全书附赠的一本习题册（20%是题，其他全是答案）；之后大概花了两周把660的高数部分做完了（这本书和全书附赠习题书相当好，一开始写可能会有难度，但是能学到很多）；也买了一本1800去写，不过题量太大，都是选择性的写一下；也去看了网课，不过是选择性的感觉哪里学的不好，就去看哪里，一般会开二倍速，我觉得网课太浪费时间，一般用网课查缺补漏；每个老师都看了一点，张宇风格偏有趣，汤家凤适合打基础，武忠祥的高数是这几个老师讲的最好的（尤其微分学，一元微分、多元微分）；5月20左右开学去看线代，看了全书的线代和李永乐的线代讲义，做了一些题，但还远远不足；后面放假前看了一遍概率论课本，暑假做了一些真题（早些年份真题很简单，一上午两套），暑假写了1000题，看了两遍全书，到暑假结束，高数应该是没问题了，9月份开始概率论，但学的很差；后面发现张宇的概率论9讲写得非常好，然后又去买了一本；</p><p>到10月份感觉差不多了就去刷题了，生疏的知识点就去翻书；</p><p>模拟题张宇的不太推荐，什么张宇八套四套的选择题可以写一写，推荐10年后的真题，李林的四套和六套，以及合共大超越（每年4-5套，共几十套），在我看来，合共大超越不简单，我大多两个小时刚刚能写完，这个试卷的题非常好，这三种试卷的模拟分数和考研最后的分数是正相关的，李林的就相对简单了，不过也蛮好；我当时自己主要再写合共大超越，主要是来锻炼抗压能力，因为这套试卷写起来没有张宇的难，同时也不简单；</p><p>市面上的习题除了李林的880基本上都写了；</p><p><strong>推荐</strong>：《李正元复习全书》、（只高数部分），《张宇概率论九讲》、《张宇线代九讲》（这两本书感觉市面上最好的讲概率论和线代的两本书）、《张宇十八讲》、《张宇1000题》、《汤家凤1800》，《李林四套》、《李林六套》、《合工大共创》、《合工大超越》（选择题部分）</p><p>数学复习的一个很大的问题是容易忘，数一考三门，需要不然重复；</p><p>我觉得考研数学最重要的两个能力：</p><ul><li>计算能力<ul><li>其实我自己从小到大都是一个非常粗心的人，中学的时候老师喜欢刷难题，然而就忽视了这种基本功，一直对简单题都不以为意，然而最后吃了大亏；四月份的时候再刷1800后面的重积分，记得当时写了13个题，错了6个还是7个，我相当受打击，我也知道我粗心的毛病；于是开始着手解决这个问题，也到百度、知乎咨询了一下，然后调整写题的态度、策略，慢慢的开始就好起来了，我对这方面觉的自己还是有一定的心得体会；</li></ul></li><li>各种知识以及性质的运用，比如看到题就知道怎么做，剩下的就交给计算能力；<ul><li>这个就是说具体的学的咋样了</li></ul></li></ul><h4 id="总结">总结</h4><p>需要注意的有：</p><ul><li>想清楚自己想不想考研，为什么考研，自己想干什么以后</li><li>已经决定了，就不顾一切的去做</li><li>考研的结果一定是你的复习情况决定的，没考好一定是自己的原因</li><li>保持谦虚，时刻做好最坏打算，比如估分的时候，以及是否二战的准备</li><li>经常给自己一些目标，清楚自己的薄弱学科、环节</li></ul><h3 id="感概">感概</h3><p>没有老实接受义务教务，最终选择考研这条路；以前我以为自己都是发挥失常，最终高考来到这里，然而慢慢的我开始直面这个事实，一切都是自己的原因，或许有遗憾，但没有后悔，对现在已经很满意；</p><p>想要不断认识一些非常厉害的人，参加比赛的时候，比如一些ACM选手，cls、csl、q、jls；比如RC、白学姐；事实证明不同平台的人起点差距很大，来自小县城的我，经常感受到这个问题，追赶它们对于我来说似乎是一件不可能事件；我不禁想什么时候能像他们一样厉害，鞭策我变得更强，想要不断地学习，学习同时能够使我更充实，不那么空虚。。</p><p>不知什么时候我也已经慢慢接受了，自己只不过是一个普通人的事实；</p><p>20有个考zju的，大家都叫他欧神，20它总分390+，但听人说数学答题卡选填忘了涂；21二战考的跟我一样，但是准备复试的过程中，听人说他英语0分，原因是二维码掉了，即使这样他也390+。。。</p><p>备考过程中也要感谢这些陪我一起的研友，在备考过程中，不用忍受孤独，大家能够互相帮助，不会的问题互相交流；当然也要感谢洋哥；我是一个不自信，并且没有主见的人，洋哥给予了我很多帮助，很多次鼓励我（但明明他比我惨），帮我指明方向，认识到杨洋是我最幸运的事之一，当然也要恭喜洋哥上岸。</p><p>考完试对答案当时是挺伤心难过的，当时对了一个机构的英语答案，发现英语阅读后面两篇几乎没有对，难受了好久，甚至做好了二战的准备；因此等到出成绩那天，就没有那么紧张了，然而成绩出来后，还是挺惊喜的；之后又经历了面试前紧张，面试后的期待与紧张，以及拟录取名单出来之后的开心与失落；这段经历注定会慢慢成为仅仅一段回忆，但它对于现在的我来说，还是相当不平凡的；</p><p>我知道自己有点社交恐惧，并且时常会“自闭”；我觉得自己情商不算低，自己的内心情感相当丰富（就是说我老是会想的很多），这既是件好事又是件坏事；我所经历的，导致我形成这样的性格；我也经常安慰自己，人无完人，不是吗？</p><p>我不知道自己能坚持到什么时候，但我有很多羁绊现在，它们支持着我不断前进；不知道未来是什么样的，也许很精彩？</p><p>砥砺前进吧，少年</p><p>看到知乎上一句话说的很好：</p><blockquote><p>我从黑暗来，奔向光明去。若有所成，若有贡献，便不负此生。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;备考回忆&quot;&gt;备考回忆&lt;/h2&gt;
&lt;p&gt;写这篇博客的目的是为了留给未来的自己一段回忆，曾经也有过为目标而努力奋斗的&lt;/p&gt;
&lt;h3 id=&quot;结果&quot;&gt;结果&lt;/h3&gt;
&lt;p&gt;2021报考中科大计算机学院，计算机学硕，初试分数：英语（一）64、政治74、专业课（408）115、数学一142，总分395；&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://chagelo.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="随笔" scheme="https://chagelo.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder-Green</title>
    <link href="https://chagelo.github.io/2021/04/09/Atcoder-Green/"/>
    <id>https://chagelo.github.io/2021/04/09/Atcoder-Green/</id>
    <published>2021-04-09T03:02:06.000Z</published>
    <updated>2021-04-11T08:37:40.502Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客记录下<a href="https://atcoder.jp/home">atcoder</a>上的绿色难度的刷题记录；</p><h3 id="abc194-e"><a href="https://atcoder.jp/contests/abc194/tasks/abc194_e">ABC194 E</a></h3><h4 id="题解">题解</h4><p>定义<span class="math inline">\(\mathrm{mex}(x_1, x_2, x_3, \dots, x_k)\)</span>为不出现在<span class="math inline">\(x_1, x_2, x_3, \dots, x_k\)</span>中的最小非负整数；</p><p>给定长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(A\)</span>，求出最小的<span class="math inline">\(\mathrm{mex}(A_{i + 1}, A_{i + 2}, A_{i + 3}, \dots, A_{i + M})\)</span>；</p><p>这类不出现在指定区间的最大值、最小值，貌似一般都需要记录每个数字出现的位置；</p><p>首先记录下每个数字的位置<span class="math inline">\(t[A[i]]\)</span>，每次让<span class="math inline">\(t[A[i]]++,t[A[i-m]]--\)</span>；并且用<span class="math inline">\(ans\)</span>记录当前的<span class="math inline">\(mex\)</span>，如果<span class="math inline">\(t[A[i-m]]=0\)</span>，那么<span class="math inline">\(A[i-m]\)</span>不出现在当前<span class="math inline">\(\text{mex}\)</span>序列中，并且如果<span class="math inline">\(A[i]\le ans\)</span>，那么它比ans更优；</p><span id="more"></span><h4 id="code">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt; <span class="keyword">int</span> , <span class="keyword">int</span> &gt; pe;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll a[N] , dp[N], num[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; ++ i)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        dp[a[i]] ++ ;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == ans)&#123;</span><br><span class="line">            ans ++;</span><br><span class="line">            <span class="keyword">while</span>(dp[ans]) ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; n; ++ i)&#123;</span><br><span class="line">        dp[a[i - m]] -- ;</span><br><span class="line">        dp[a[i]] ++;</span><br><span class="line">        <span class="keyword">if</span>(dp[a[i - m]] == <span class="number">0</span> &amp;&amp; ans &gt; a[i - m])&#123;</span><br><span class="line">            ans = a[i - m];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc188-d"><a href="https://atcoder.jp/contests/abc188/tasks/abc188_d">ABC188 D</a></h3><h4 id="题解-1">题解</h4><h4 id="code-1">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll N, C;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; C;</span><br><span class="line">    vector&lt;pair&lt;ll, ll&gt;&gt; event;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        ll a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        event.<span class="built_in">emplace_back</span>(a - <span class="number">1</span>, c);</span><br><span class="line">        event.<span class="built_in">emplace_back</span>(b, -c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(event.<span class="built_in">begin</span>(), event.<span class="built_in">end</span>());</span><br><span class="line">    ll ans = <span class="number">0</span>, fee = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : event)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x != t)&#123;</span><br><span class="line">            ans += <span class="built_in">min</span>(C, fee) * (x - t);</span><br><span class="line">            t = x;</span><br><span class="line">        &#125;</span><br><span class="line">        fee += y;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc188-e"><a href="https://atcoder.jp/contests/abc188/tasks/abc188_e">ABC188 E</a></h3><h4 id="题解-2">题解</h4><p>给了一个<span class="math inline">\(n\)</span>个点的有向图，以及每个点的权值<span class="math inline">\(A[i]\)</span>，一开始可以在任意一个点花费<span class="math inline">\(A[i]\)</span>买黄金，之后通过有向图到达其他点，再在某个点<span class="math inline">\(j\)</span>卖出黄金获得<span class="math inline">\(A[j]\)</span>的金钱；问这个过程最多可以获利多少钱；</p><p>整张图可能是由若干个连通量构成；因为一开始可以在任意一点，那么最好的情况就是肯定一开始在买入的地方，那么贪心的想，它肯定权值<span class="math inline">\(A\)</span>尽可能小，之后从最小点开始枚举（需要一个<span class="math inline">\(vis\)</span>来剪枝），进行<span class="math inline">\(bfs\)</span>，每次记录遍历到当前点之前的最小的<span class="math inline">\(A\)</span>作为买入的值<span class="math inline">\(buy\)</span>，然后每到一个点<span class="math inline">\(v\)</span>，用<span class="math inline">\(A[v]-buy\)</span>来更新<span class="math inline">\(answer\)</span>；</p><p>用<span class="math inline">\(bfs\)</span>也可以，从具有最小的<span class="math inline">\(A[i]\)</span>的点<span class="math inline">\(i\)</span>出发，遍历从<span class="math inline">\(i\)</span>出发能到达的所有点<span class="math inline">\(j\)</span>，更新<span class="math inline">\(ans=A[j] - A[i]\)</span>；然后第二次从具有第二小<span class="math inline">\(A\)</span>的点出发，并且这一次，不用访问那些从<span class="math inline">\(i\)</span>出发能到达的点（因为上次一从最小权值开始出发）；</p><p>另外一种做法就是，由于题目告诉我们<span class="math inline">\(x_i \lt y_i\)</span>，那么我们可以从<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>遍历点，同时遍历点<span class="math inline">\(i\)</span>所出去的边，对于点<span class="math inline">\(u\)</span>，求出在访问<span class="math inline">\(u\)</span>之前的点中，买入所需的最小价格<span class="math inline">\(buy\)</span>（不包括<span class="math inline">\(u\)</span>），之后拿<span class="math inline">\(A[u]-buy\)</span>更新<span class="math inline">\(ans\)</span>；</p><h4 id="code-2">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, A[<span class="number">200005</span>], vis[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> buy)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = vec[x][i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, A[v] - buy);</span><br><span class="line">            <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(buy, A[v]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        vec[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        vex.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vex.<span class="built_in">begin</span>(), vex.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[a] &lt; A[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;u: vex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[u]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(u, A[u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">chmax</span><span class="params">(T&amp; a, T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) &#123; a = b; <span class="keyword">return</span> <span class="number">1</span>; &#125; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">chmin</span><span class="params">(T&amp; a, T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) &#123; a = b; <span class="keyword">return</span> <span class="number">1</span>; &#125; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for (int i = 0; i &lt; (n); ++i)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> P = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1001001001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, n) &#123; cin &gt;&gt; a[i]; &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">G</span>(n);</span><br><span class="line">    <span class="built_in">rep</span>(i, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        x--;</span><br><span class="line">        y--;</span><br><span class="line">        G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">buy</span><span class="params">(n, <span class="number">1e18</span>)</span></span>;</span><br><span class="line">    ll ans = <span class="number">-1e18</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, n) &#123;</span><br><span class="line">        <span class="built_in">chmax</span>(ans, a[i] - buy[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u : G[i]) &#123;</span><br><span class="line">            <span class="built_in">chmin</span>(buy[u], <span class="built_in">min</span>(buy[i], a[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc185-f"><a href="https://atcoder.jp/contests/abc185/tasks/abc185_f">ABC185 F</a></h3><h4 id="题解-3">题解</h4><p>方法很多，线段树、树状数组（才知道树状数组还叫作<span class="math inline">\(Fenwick tree\)</span>）；异或的性质应用到区间之上；定义<span class="math inline">\(f(i) = A_1 \oplus A_2 \oplus A_3 \oplus \dots \oplus A_i\)</span>，那么<span class="math inline">\([x_i,y_i]\)</span>之间的答案就是<span class="math inline">\(f(Y_i) \oplus f(X_i - 1)\)</span>;</p><h4 id="code-3">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, A[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  x = pos; x &lt;= n; x += x &amp; -x) &#123;</span><br><span class="line">        A[x] ^= val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = pos; x; x -= x &amp; -x)</span><br><span class="line">        ans ^= A[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">update</span>(i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, x, y;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">update</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; (<span class="built_in">sum</span>(y) ^ <span class="built_in">sum</span>(x - <span class="number">1</span>)) &lt;&lt; endl;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc193-d"><a href="https://atcoder.jp/contests/abc193/tasks/abc193_d">ABC193 D</a></h3><h4 id="题解-4">题解</h4><p>暴力即可，枚举<span class="math inline">\(s\)</span>与<span class="math inline">\(t\)</span>的可能情况；</p><h4 id="code-4">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, cnt[<span class="number">11</span>][<span class="number">2</span>], ans[<span class="number">11</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        cnt[s[i] - <span class="string">&#x27;0&#x27;</span>][<span class="number">0</span>]++;</span><br><span class="line">        cnt[t[i] - <span class="string">&#x27;0&#x27;</span>][<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> anst = <span class="number">0</span>, anss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnttemp[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        ans[i][<span class="number">0</span>] = i * <span class="built_in">pow</span>(<span class="number">10</span>, cnt[i][<span class="number">0</span>]);</span><br><span class="line">        ans[i][<span class="number">1</span>] = i * <span class="built_in">pow</span>(<span class="number">10</span>, cnt[i][<span class="number">1</span>]);</span><br><span class="line">        anss += ans[i][<span class="number">0</span>];</span><br><span class="line">        anst += ans[i][<span class="number">1</span>];</span><br><span class="line">        cnttemp[i] = k - cnt[i][<span class="number">0</span>] - cnt[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ltc = <span class="number">9</span> * k - <span class="number">8</span>;</span><br><span class="line">    ll all_cnt = <span class="number">1ll</span> * ltc * (ltc - <span class="number">1</span>);</span><br><span class="line">    ll x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnttemp[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (anss + <span class="number">9</span> * ans[i][<span class="number">0</span>] &gt; anst + <span class="number">9</span> * ans[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j <span class="keyword">and</span> cnttemp[j] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        x += <span class="number">1ll</span> * cnttemp[i] * (cnttemp[i] - <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != j <span class="keyword">and</span> cnttemp[j]) &#123;</span><br><span class="line">                        x += <span class="number">1ll</span> * cnttemp[i] * cnttemp[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">1.0</span> * x / all_cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方代码。。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">score</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : S) cnt[c - <span class="string">&#x27;0&#x27;</span>] *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll K;</span><br><span class="line">    string S, T;</span><br><span class="line">    cin &gt;&gt; K &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>, K)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : S + T) cnt[c - <span class="string">&#x27;0&#x27;</span>]--;</span><br><span class="line">    ll win = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll x = <span class="number">1</span>; x &lt;= <span class="number">9</span>; x++) <span class="keyword">for</span>(ll y = <span class="number">1</span>; y &lt;= <span class="number">9</span>; y++)&#123;</span><br><span class="line">        S.<span class="built_in">back</span>() = <span class="string">&#x27;0&#x27;</span> + x;</span><br><span class="line">        T.<span class="built_in">back</span>() = <span class="string">&#x27;0&#x27;</span> + y;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">score</span>(S) &lt;= <span class="built_in">score</span>(T)) <span class="keyword">continue</span>;</span><br><span class="line">        win += cnt[x] * (cnt[y] - (x == y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> ll rem = <span class="number">9</span> * K - <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">double</span></span>(win) / rem / (rem - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">K = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">S = <span class="built_in">input</span>()[:<span class="number">4</span>]</span><br><span class="line">T = <span class="built_in">input</span>()[:<span class="number">4</span>]</span><br><span class="line">cnt = [K] * <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">    cnt[<span class="built_in">int</span>(c)] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> T:</span><br><span class="line">    cnt[<span class="built_in">int</span>(c)] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">S</span>):</span></span><br><span class="line">    cnt = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">        cnt[<span class="built_in">int</span>(c)] += <span class="number">1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        ans += i * <span class="number">10</span> ** cnt[i]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> cnt[i] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> i == j <span class="keyword">or</span> cnt[j] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> score(S + <span class="built_in">str</span>(i)) &gt; score(T + <span class="built_in">str</span>(j)):</span><br><span class="line">            ans += cnt[i] * cnt[j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> cnt[i] &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> score(S + <span class="built_in">str</span>(i)) &gt; score(T + <span class="built_in">str</span>(i)):</span><br><span class="line">        ans += cnt[i] * (cnt[i] - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">9</span> * K - <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(ans / N / (N - <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc182-e"><a href="https://atcoder.jp/contests/abc182/tasks/abc182_e">ABC182 E</a></h3><h4 id="题解-5">题解</h4><h4 id="code-5">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,n) for (int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> P = pair&lt;ll,ll&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H,W,N,M;</span><br><span class="line"><span class="keyword">int</span> ver[<span class="number">1500</span>][<span class="number">1500</span>];</span><br><span class="line"><span class="keyword">int</span> sid[<span class="number">1500</span>][<span class="number">1500</span>];</span><br><span class="line"><span class="keyword">int</span> des[<span class="number">1500</span>][<span class="number">1500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vertical</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || H&lt;=x || des[x][y] || ver[x][y])<span class="keyword">return</span>;</span><br><span class="line">    ver[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vertical</span>(x+<span class="number">1</span>,y);</span><br><span class="line">    <span class="built_in">vertical</span>(x<span class="number">-1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">side</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;<span class="number">0</span> || W&lt;=y || des[x][y] || sid[x][y])<span class="keyword">return</span>;</span><br><span class="line">    sid[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">side</span>(x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">side</span>(x,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;H&gt;&gt;W&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    vector&lt;P&gt;L;</span><br><span class="line">    <span class="built_in">rep</span>(i,N)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;a--;b--;</span><br><span class="line">        L.<span class="built_in">push_back</span>(&#123;a,b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,M)&#123;</span><br><span class="line">        <span class="keyword">int</span> c,d;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;d;c--;d--;</span><br><span class="line">        des[c][d]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i,N)&#123;</span><br><span class="line">        <span class="built_in">vertical</span>(L[i].first,L[i].second);</span><br><span class="line">        <span class="built_in">side</span>(L[i].first,L[i].second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,H)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,W)&#123;</span><br><span class="line">            ans+=(ver[i][j]||sid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc181-e"><a href="https://atcoder.jp/contests/abc181/tasks/abc181_e">ABC181 E</a></h3><h4 id="题解-6">题解</h4><p>一种自然的想法就是，将<span class="math inline">\(n\)</span>个人的身高<span class="math inline">\(h\)</span>排序，然后枚举<span class="math inline">\(w_i\)</span>，插入<span class="math inline">\(h\)</span>中，求出所有情况下的最小值；</p><p>但是其实可以不用每次都求一边答案；其实只需要考虑插入位置；比如对于<code>a b c x d e</code>和<code>a b x c d e</code>；只需要预处理<span class="math inline">\(|H_{2i-1}-H_{2i}|\)</span>和<span class="math inline">\(|H_{2i}-H_{2i+1}|\)</span>，这种题第一次见；这题标答还给了滑动窗口的解法；</p><h4 id="code-6">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chmin</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">if</span>(a &gt; b)&#123; a = b; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">H</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; h : H) cin &gt;&gt; h;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">W</span><span class="params">(M)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; w : W) cin &gt;&gt; w;</span><br><span class="line">    <span class="built_in">sort</span>(H.<span class="built_in">begin</span>(), H.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum1</span><span class="params">((N + <span class="number">1</span>) / <span class="number">2</span>)</span>, <span class="title">sum2</span><span class="params">((N + <span class="number">1</span>) / <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; N; i += <span class="number">2</span>) sum1[i / <span class="number">2</span> + <span class="number">1</span>] = sum1[i / <span class="number">2</span>] + H[i + <span class="number">1</span>] - H[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>) sum2[i / <span class="number">2</span>] = sum2[i / <span class="number">2</span> + <span class="number">1</span>] + H[i + <span class="number">1</span>] - H[i];</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w : W)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">lower_bound</span>(H.<span class="built_in">begin</span>(), H.<span class="built_in">end</span>(), w) - H.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) x ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">chmin</span>(ans, sum1[x / <span class="number">2</span>] + sum2[x / <span class="number">2</span>] + <span class="built_in">abs</span>(H[x] - w));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc178-e"><a href="https://atcoder.jp/contests/abc178/tasks/abc178_e">ABC178 E</a></h3><h4 id="题解-7">题解</h4><p>求曼哈顿距离，比较经典； https://www.cnblogs.com/tanhehe/archive/2013/05/25/3099400.html</p><h4 id="code-7">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">t1 = []</span><br><span class="line">t2 = []</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">    x, y = <span class="built_in">map</span>(<span class="keyword">int</span>, <span class="built_in">input</span>().<span class="built_in">split</span>())</span><br><span class="line">    t1.<span class="built_in">append</span>(x - y)</span><br><span class="line">    t2.<span class="built_in">append</span>(x + y)</span><br><span class="line">t1.<span class="built_in">sort</span>()</span><br><span class="line">t2.<span class="built_in">sort</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(t1[<span class="number">-1</span>] - t1[<span class="number">0</span>], t2[<span class="number">-1</span>] - t2[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇博客记录下&lt;a href=&quot;https://atcoder.jp/home&quot;&gt;atcoder&lt;/a&gt;上的绿色难度的刷题记录；&lt;/p&gt;
&lt;h3 id=&quot;abc194-e&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc194/tasks/abc194_e&quot;&gt;ABC194 E&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;题解&quot;&gt;题解&lt;/h4&gt;
&lt;p&gt;定义&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{mex}(x_1, x_2, x_3, \dots, x_k)\)&lt;/span&gt;为不出现在&lt;span class=&quot;math inline&quot;&gt;\(x_1, x_2, x_3, \dots, x_k\)&lt;/span&gt;中的最小非负整数；&lt;/p&gt;
&lt;p&gt;给定长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的序列&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，求出最小的&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{mex}(A_{i + 1}, A_{i + 2}, A_{i + 3}, \dots, A_{i + M})\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;这类不出现在指定区间的最大值、最小值，貌似一般都需要记录每个数字出现的位置；&lt;/p&gt;
&lt;p&gt;首先记录下每个数字的位置&lt;span class=&quot;math inline&quot;&gt;\(t[A[i]]\)&lt;/span&gt;，每次让&lt;span class=&quot;math inline&quot;&gt;\(t[A[i]]++,t[A[i-m]]--\)&lt;/span&gt;；并且用&lt;span class=&quot;math inline&quot;&gt;\(ans\)&lt;/span&gt;记录当前的&lt;span class=&quot;math inline&quot;&gt;\(mex\)&lt;/span&gt;，如果&lt;span class=&quot;math inline&quot;&gt;\(t[A[i-m]]=0\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(A[i-m]\)&lt;/span&gt;不出现在当前&lt;span class=&quot;math inline&quot;&gt;\(\text{mex}\)&lt;/span&gt;序列中，并且如果&lt;span class=&quot;math inline&quot;&gt;\(A[i]\le ans\)&lt;/span&gt;，那么它比ans更优；&lt;/p&gt;</summary>
    
    
    
    <category term="Atcoder" scheme="https://chagelo.github.io/categories/Atcoder/"/>
    
    <category term="绿色" scheme="https://chagelo.github.io/categories/Atcoder/%E7%BB%BF%E8%89%B2/"/>
    
    
    <category term="atcoder" scheme="https://chagelo.github.io/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder Brown</title>
    <link href="https://chagelo.github.io/2021/03/29/Atcoder-Brown/"/>
    <id>https://chagelo.github.io/2021/03/29/Atcoder-Brown/</id>
    <published>2021-03-29T09:09:28.000Z</published>
    <updated>2021-04-09T03:51:03.432Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客记录下<a href="https://atcoder.jp/home">atcoder</a>上的棕色难度的刷题记录；</p><h3 id="abc190-c---bowls-and-dishes"><a href="https://atcoder.jp/contests/abc190/tasks/abc190_c">ABC190 C - Bowls and Dishes</a></h3><h4 id="题解">题解</h4><p>这里由于<span class="math inline">\(k\)</span>最大只有<span class="math inline">\(16\)</span>，因此可以用暴力，这里使用二进制进行枚举，第<span class="math inline">\(i\)</span>位为0表示，选择将球放在<span class="math inline">\(C_i\)</span>中，否则放在<span class="math inline">\(D_i\)</span>中；之后判断<span class="math inline">\(m\)</span>个<span class="math inline">\(condition\)</span>满足了多少个，然后更新最大值；</p><span id="more"></span><h4 id="code">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, dish[<span class="number">104</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c, d;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        p.<span class="built_in">push_back</span>(&#123;c, d&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dish, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dish));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) dish[p[j].first]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dish[p[j].second]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: vec)</span><br><span class="line">            <span class="keyword">if</span> (dish[x.first] &amp;&amp; dish[x.second]) cnt++;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc190-d---staircase-sequences-editorial"><a href="https://atcoder.jp/contests/abc190/tasks/abc190_d">ABC190 D - Staircase Sequences Editorial</a></h3><h4 id="题解-1">题解</h4><p>题目即让我们求满足<span class="math inline">\(\frac{(A+B)(B-A+1)}{2}=2N\)</span>的<span class="math inline">\((B-A+1)\)</span>的种类数乘以<span class="math inline">\(2\)</span>；并且一个重要的隐含条件是，<span class="math inline">\(A+B\)</span>与<span class="math inline">\(B-A+1\)</span>必定是一奇一偶；</p><h4 id="code-1">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    n = n * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1ll</span> * i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> &amp;&amp; i % <span class="number">2</span> != n / i % <span class="number">2</span>)</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans * <span class="number">2</span>&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc189-c"><a href="https://atcoder.jp/contests/abc189/tasks/abc189_c">ABC189 C</a></h3><h4 id="题解-2">题解</h4><p>题目的意思是这样的，给定一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>，求<span class="math inline">\(\max((l-r+1)\times \min(a_l\dots a_r))\)</span></p><p>这个题目其实可以暴力，复杂度<span class="math inline">\(O(n^2)\)</span>，也可以用单调栈；对于<span class="math inline">\(a[i]\)</span>，分别求除左边和右边比他小的数的位置，<span class="math inline">\(l_i,r_i\)</span>，那么以<span class="math inline">\(a[i]\)</span>为最小值的最长区间为<span class="math inline">\(\left[l_i + 1, r_i - 1\right]\)</span>；然后不断更新答案即可；</p><h4 id="code-2">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l[<span class="number">10005</span>], r[<span class="number">10004</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        r[i] = l[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>() &amp;&amp; a[s1.<span class="built_in">top</span>()] &gt;= a[i]) s1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!s1.<span class="built_in">empty</span>()) l[i] = s1.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">        s1.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s2.<span class="built_in">empty</span>() &amp;&amp; a[s2.<span class="built_in">top</span>()] &gt;= a[i]) s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!s2.<span class="built_in">empty</span>()) r[i] = s2.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">        s2.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, a[i] * (r[i] - l[i] + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc189-d"><a href="https://atcoder.jp/contests/abc189/tasks/abc189_d">ABC189 D</a></h3><h4 id="题解-3">题解</h4><p>题意：给定<span class="math inline">\(n\)</span>个字符串<span class="math inline">\(s_1\dots s_n\)</span>，求序列<span class="math inline">\((x_0\dots x_n)\)</span>的个数，该序列保证<span class="math inline">\(y_n\)</span>结果为<code>True</code>；其中<span class="math inline">\(y_0=x_0\)</span>，如果<span class="math inline">\(s_i\)</span>为<code>AND</code>，那么<span class="math inline">\(y_i=y_{i-1}\&amp;x_i\)</span>，若<span class="math inline">\(s_i\)</span>为<code>OR</code>，那么<span class="math inline">\(y_i = y_{i - 1}|x_i\)</span>；其中<span class="math inline">\(x_i\)</span>只能为<code>True</code>或<code>False</code>；</p><p>令<span class="math inline">\(dp[i][0/1]\)</span>表示前<span class="math inline">\(i\)</span>个变量的结果为<code>True</code>或<code>False</code>的情况下的序列的个数；</p><h4 id="code-3">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, dp[<span class="number">103</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">string s[<span class="number">103</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;test.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&quot;AND&quot;</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>] * <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] * <span class="number">2</span> + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc187-d"><a href="https://atcoder.jp/contests/abc189/tasks/abc189_d">ABC187 D</a></h3><h4 id="题解-4">题解</h4><p>这题不能<span class="math inline">\(A_i+B_i\)</span>贪心，因为某一步的贪心并不能保证全局的最优；实际上每次选择都会影响到后序的选择情况；</p><p>按<span class="math inline">\(2A_i+B_i\)</span>贪心的从大到小选是可行的；</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//按A+B排</span><br><span class="line">5</span><br><span class="line">2 6 </span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">//按2*A+B排</span><br><span class="line">5</span><br><span class="line">5 2</span><br><span class="line">2 6</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h4 id="code-4">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    ll X = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">x</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        ll A, B;</span><br><span class="line">        cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">        X -= A;</span><br><span class="line">        x[i] = A + A + B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(X &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        X += x.<span class="built_in">back</span>();</span><br><span class="line">        x.<span class="built_in">pop_back</span>();</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc186-d"><a href="https://atcoder.jp/contests/abc186/tasks/abc186_d">ABC186 D</a></h3><h4 id="题解-5">题解</h4><p>对于长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(A\)</span>，求<span class="math inline">\(\displaystyle{\sum_{i=1}^{N-1}\sum_{j=i+1}^{N} |A_i-A_j|}\)</span>；</p><p>即求所有任意两个元素差绝对值的和；</p><p>实际上这个结果跟<span class="math inline">\(A\)</span>的排列顺序无关，因此如果A是升序的；</p><p>那么即求，对任意的<span class="math inline">\(i\)</span>，<span class="math inline">\(\sum_{j=i+1}^{N}|A_i-A_j|=(\sum_{j=i+1}^{N}A_j)-(N-i)A_i\)</span></p><h4 id="code-5">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    ll sum = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += <span class="number">1ll</span> * (i - <span class="number">1</span>) * a[i];</span><br><span class="line">        temp += <span class="number">1ll</span> * (n - i) * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum - temp &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc185-d"><a href="https://atcoder.jp/contests/abc185/tasks/abc185_d">ABC185 D</a></h3><h4 id="code-6">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">    a[m + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] - a[i - <span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        step = <span class="built_in">min</span>(step, a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans += <span class="built_in">ceil</span>(<span class="number">1.0</span> * (a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>) / step);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc183-d"><a href="https://atcoder.jp/contests/abc183/tasks/abc183_d">ABC183 D</a></h3><h4 id="题解-6">题解</h4><p>往一个全<span class="math inline">\(0\)</span>序列进行区间加的操作，最后问是否有某个位置的和大于<span class="math inline">\(w\)</span>；这里可以使用树状数组，之后查询每个位置的和即可；或者直接差分更简单；小心爆<span class="math inline">\(int\)</span></p><h4 id="code-7">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, w, bit[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; <span class="number">200005</span>; i += i &amp; -i)</span><br><span class="line">        bit[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i)</span><br><span class="line">        ans += <span class="number">1ll</span> * bit[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; w;</span><br><span class="line">    <span class="keyword">int</span> maxm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s, t, p;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t &gt;&gt; p;</span><br><span class="line">        maxm = <span class="built_in">max</span>(maxm, t + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">insert</span>(s + <span class="number">1</span>, p);</span><br><span class="line">        <span class="built_in">insert</span>(t + <span class="number">1</span>, -p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxm; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sum</span>(i) &gt; w) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc182-d"><a href="https://atcoder.jp/contests/abc182/tasks/abc182_d">ABC182 D</a></h3><h4 id="code-8">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, a[<span class="number">200005</span>], sum[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll ans = <span class="number">0</span>, sum = <span class="number">0</span>, maxm = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum += a[i];</span><br><span class="line">        maxm = <span class="built_in">max</span>(maxm, sum);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, pre + maxm);</span><br><span class="line">        pre += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc181-d"><a href="https://atcoder.jp/contests/abc181/tasks/abc181_d">ABC181 D</a></h3><h4 id="题解-7">题解</h4><p>因为<span class="math inline">\(1000=8\times 125\)</span>，因此<span class="math inline">\(10^3、10^4\dots\)</span>都是<span class="math inline">\(8\)</span>的倍数，实际上只需要判断最后<span class="math inline">\(3\)</span>位即可；</p><p><span class="math inline">\(1000\)</span>以内<span class="math inline">\(8\)</span>的倍数可以枚举出来，对于每个数，判断<span class="math inline">\(s\)</span>中是否有字符能够组成它即可；</p><h4 id="code-9">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> s == <span class="string">&quot;8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stoi</span>(s) % <span class="number">8</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(s) % <span class="number">8</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> x : s) cnt[x - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">112</span>; i &lt; <span class="number">1000</span>; i += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> c = cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> x : <span class="built_in">to_string</span>(i)) c[x - <span class="string">&#x27;0&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">all_of</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x &gt;= <span class="number">0</span>; &#125;)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">solve</span>(s) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc178-c"><a href="https://atcoder.jp/contests/abc178/tasks/abc178_c">ABC178 C</a></h3><h4 id="题解-8">题解</h4><p>容斥原理，直接求包含<span class="math inline">\(0\)</span>和<span class="math inline">\(9\)</span>的不好求，分别求出仅不包含<span class="math inline">\(0\)</span>和仅不包含<span class="math inline">\(9\)</span>的可能数，在求出不包含<span class="math inline">\(0\)</span>和<span class="math inline">\(9\)</span>的可能数；</p><h4 id="code-10">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;y;i++)&#123;</span><br><span class="line">        res=res*x%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    ll ans=<span class="built_in">powmod</span>(<span class="number">10</span>,n)-<span class="built_in">powmod</span>(<span class="number">9</span>,n)-<span class="built_in">powmod</span>(<span class="number">9</span>,n)+<span class="built_in">powmod</span>(<span class="number">8</span>,n);</span><br><span class="line">    ans%=mod;</span><br><span class="line">    ans=(ans+mod)%mod;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc177-d"><a href="https://atcoder.jp/contests/abc177/tasks/abc177_d">ABC177 D</a></h3><h4 id="题解-9">题解</h4><p>这是一个并查集计数的问题，实际上就是需要我们求所有连通量中，最大的那个包含多少个元素；</p><h4 id="code-11">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">200005</span>], f[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        f[i] = i, cnt[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">int</span> fu = <span class="built_in">find</span>(u), fv = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (fu != fv)  &#123;</span><br><span class="line">            f[fu] = f[fv] = fu;</span><br><span class="line">            cnt[fu] = cnt[fu] + cnt[fv];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        maxm = <span class="built_in">max</span>(maxm, cnt[<span class="built_in">find</span>(i)]);</span><br><span class="line">    cout &lt;&lt; maxm &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc175-c"><a href="https://atcoder.jp/contests/abc175/tasks/abc175_c">ABC175 C</a></h3><h4 id="code-12">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll X, K, D;</span><br><span class="line">    cin &gt;&gt; X &gt;&gt; K &gt;&gt; D;</span><br><span class="line">    X = <span class="built_in">abs</span>(X);</span><br><span class="line"></span><br><span class="line">    ll straight = <span class="built_in">min</span>(K, X / D);</span><br><span class="line">    K -= straight;</span><br><span class="line">    X -= straight * D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (K % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; X &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; D - X &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc173-c"><a href="https://atcoder.jp/contests/abc173/tasks/abc173_c">ABC173 C</a></h3><h4 id="题解-10">题解</h4><p>数据非常的小，可以暴力；用二进制枚举行与列的所有的选择的情况，然后统计<code>#</code>的数量为<span class="math inline">\(k\)</span>的情况；</p><h4 id="code-13">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h, k, w;</span><br><span class="line"></span><br><span class="line">string s[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; h &gt;&gt; w &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; h; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; w; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; h; r++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; w; c++)</span><br><span class="line">                    <span class="keyword">if</span> (s[r][c] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; (i &gt;&gt; r &amp; <span class="number">1</span>) &amp;&amp; (j &gt;&gt; c &amp; <span class="number">1</span>)) cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc169-c"><a href="https://atcoder.jp/contests/abc169/tasks/abc169_c">ABC169 C</a></h3><h4 id="题解-11">题解</h4><p>这点需要注意，<span class="math inline">\(double\)</span>在内存中都是近似存储的（<span class="math inline">\(\text{IEEE754}\)</span>），比如<span class="math inline">\(0.1\)</span>并不能精确的表示； 因此可以想象如果把这个<span class="math inline">\(double\)</span>再乘上一个很大的数，那么这其中的误差就会被放大；这里可以将<span class="math inline">\(double\)</span>当作一个字符串，将小数部分按位计算，或者使用<code>std::round</code>；</p><h4 id="code-14">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    b = <span class="built_in">round</span>(b * <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; a * (ll)b / <span class="number">100</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc165-d"><a href="https://atcoder.jp/contests/abc165/tasks/abc165_d">ABC165 D</a></h3><h4 id="题解-12">题解</h4><p>定义<span class="math inline">\(f(x) = floor(\frac{Ax}{B}) − A × floor(\frac{x}{B})\)</span>，那么有<span class="math inline">\(f(x + B) = f(x)\)</span>；那么不妨假设<span class="math inline">\(0\leq x\leq n - 1\)</span>，则<span class="math inline">\(f(x)=floor(\frac{Ax}{B})\)</span>，此时由于<span class="math inline">\(f(x)\)</span>是单调不减的，则<span class="math inline">\(x\)</span>越大越好，那么当<span class="math inline">\(x\)</span>取<span class="math inline">\(min(B-1,N)\)</span>时，<span class="math inline">\(f(x)\)</span>最大；</p><h4 id="code-15">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">ll a, b, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="function">a * <span class="title">min</span><span class="params">(b - <span class="number">1</span>, n)</span> / b</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc159-d"><a href="https://atcoder.jp/contests/abc159/tasks/abc159_d">ABC159 D</a></h3><h4 id="题解-13">题解</h4><p>首先统计每个数字出现次数，那么从<span class="math inline">\(N\)</span>个数字中取两个相同的总的方法数也就知道了；对于<span class="math inline">\(A[i]\)</span>来说，要求从<span class="math inline">\(A[i]\)</span>外的<span class="math inline">\(N-1\)</span>个数字中取2个相同的，只需要拿总的方法数减去<span class="math inline">\(A[i]\)</span>的贡献即可；</p><h4 id="code-16">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * x * (x - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">200005</span>], cnt[<span class="number">200005</span>];</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">        s.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>();it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        sum += <span class="built_in">C</span>(cnt[*it]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cout &lt;&lt; sum - (cnt[a[i]] - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="abc150-c"><a href="https://atcoder.jp/contests/abc150/tasks/abc150_c">ABC150 C</a></h3><h4 id="题解-14">题解</h4><p>给了我们长度为<span class="math inline">\(n\)</span>的两个<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>全排列，然后需要我们求它们字典序差的绝对值；一开始的想法是，由于<span class="math inline">\(n\)</span>最大是<span class="math inline">\(n\)</span>，那么可以求出<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>所有全排列，然后利用<span class="math inline">\(hash\)</span>记录字典序（<span class="math inline">\(c++\)</span>的<code>next_permutation</code>是按字典序递增生成排列的），之后求差；</p><p>看了题解，不一样的是，题解是把排列看成整数，然后分别求出所有排列中，小于排列<span class="math inline">\(a、b\)</span>对应整数的排列有多少个，然后相减；</p><p>这里又用了一下<span class="math inline">\(python\)</span>，<span class="math inline">\(python\)</span>的<span class="math inline">\(itertools\)</span>提供了很多函数，其中的<span class="math inline">\(itertools.permutation\)</span>需要一个可迭代对象作为参数（可以是字符串！）；</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"> </span><br><span class="line">st = <span class="string">&quot;ABC&quot;</span></span><br><span class="line"> </span><br><span class="line">per = itertools.permutations(st)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> per:</span><br><span class="line">    <span class="built_in">print</span>(*val)</span><br><span class="line"><span class="comment"># A B C</span></span><br><span class="line"><span class="comment"># A C B</span></span><br><span class="line"><span class="comment"># B A C</span></span><br><span class="line"><span class="comment"># B C A</span></span><br><span class="line"><span class="comment"># C A B</span></span><br><span class="line"><span class="comment"># C B A</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"> </span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line">per = itertools.permutations(values, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> per:</span><br><span class="line">    <span class="built_in">print</span>(*val)</span><br><span class="line"><span class="comment"># 1 2</span></span><br><span class="line"><span class="comment"># 1 3</span></span><br><span class="line"><span class="comment"># 1 4</span></span><br><span class="line"><span class="comment"># 2 1</span></span><br><span class="line"><span class="comment"># 2 3</span></span><br><span class="line"><span class="comment"># 2 4</span></span><br><span class="line"><span class="comment"># 3 1</span></span><br><span class="line"><span class="comment"># 3 2</span></span><br><span class="line"><span class="comment"># 3 4</span></span><br><span class="line"><span class="comment"># 4 1</span></span><br><span class="line"><span class="comment"># 4 2</span></span><br><span class="line"><span class="comment"># 4 3</span></span><br></pre></td></tr></table></figure><h4 id="code-17">code</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">l</span>):</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> l:</span><br><span class="line">        ans = ans * <span class="number">10</span> + x</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">b = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">cal_a = cal(a)</span><br><span class="line">cal_b = cal(b)</span><br><span class="line"></span><br><span class="line">val = itertools.permutations(<span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">les_a = <span class="number">0</span></span><br><span class="line">les_b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> val:</span><br><span class="line">    temp = cal(x)</span><br><span class="line">    <span class="keyword">if</span> temp &lt; cal_a:</span><br><span class="line">        les_a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> temp &lt; cal_b:</span><br><span class="line">        les_b += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(les_a - les_b))</span><br></pre></td></tr></table></figure><h3 id="abc149-d"><a href="https://atcoder.jp/contests/abc149/tasks/abc149_d">ABC149 D</a></h3><h4 id="题解-15">题解</h4><p>对于给定的<span class="math inline">\(A、B、X\)</span>，我们需要求满足<span class="math inline">\(A\times N+B\times d(N)\leq X\)</span>的最大的N，<span class="math inline">\(d(N)\)</span>是<span class="math inline">\(N\)</span>有多少位，N的范围是<span class="math inline">\(1\)</span>到<span class="math inline">\(10^9\)</span>；</p><p>我们可以枚举<span class="math inline">\(d(N)\)</span>，这样<span class="math inline">\(N\)</span>的范围就确定了，再枚举<span class="math inline">\(N\)</span>找到满足条件的<span class="math inline">\(N\)</span>；</p><h4 id="code-18">code</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">n, x</span>):</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n //= <span class="number">10</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cnt == x:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">a, b, x = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    upp = (x - b * i) // a</span><br><span class="line">    low = <span class="built_in">pow</span>(<span class="number">10</span>, i - <span class="number">1</span>)</span><br><span class="line">    upp = <span class="built_in">min</span>(<span class="built_in">pow</span>(<span class="number">10</span>, i) - <span class="number">1</span>, upp, <span class="built_in">int</span>(<span class="number">1e9</span>))</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(upp, low - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> check(n, i):</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, n)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h3 id="abc137-d"><a href="https://atcoder.jp/contests/abc137/tasks/abc137_d">ABC137 D</a></h3><h4 id="题解-16">题解</h4><p>一开始是想直接对<span class="math inline">\(value\)</span>进行贪心，但是会有这样一个问题比如两个工作<code>2 1</code>和<code>1 2</code>，<span class="math inline">\(M\)</span>是3，如果优先选<span class="math inline">\(value\)</span>大的，那么<code>1 2</code>就不能第一个，那么如果选它，就只能在第<span class="math inline">\(2\)</span>天做，那它的报酬只能在第<span class="math inline">\(4\)</span>天获得（大于<span class="math inline">\(M\)</span>）；</p><p>通过对时间排序（也就是延迟获得报酬的时间尽量小），从最后一天往前，筛选出最迟完成时间在同一天的工作，从中选出价值最大的；</p><p>如果在最后一天做，只能做完成后<span class="math inline">\(1\)</span>天就可以获得报酬的工作，倒数第二天做，只能做完成后<span class="math inline">\(1\)</span>或<span class="math inline">\(2\)</span>天就可以获得报酬的工作，<span class="math inline">\(\dots\)</span>；</p><h4 id="code-19">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> job&amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.a &gt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; jo[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; jo[i].a &gt;&gt; jo[i].b;</span><br><span class="line">    <span class="built_in">sort</span>(jo + <span class="number">1</span>, jo + <span class="number">1</span> + n);</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>, k = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= n &amp;&amp; cnt &gt;= jo[k].a) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(jo[k].b);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            multiset&lt;<span class="keyword">int</span>&gt;::iterator pos = --s.<span class="built_in">end</span>();</span><br><span class="line">            ans += *pos;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abc143-d"><a href="https://atcoder.jp/contests/abc143/tasks/abc143_d">ABC143 D</a></h3><h4 id="题解-17">题解</h4><p>给定一个序列，需要求能够组成三角形的三元组的个数；考虑三条边从小到大的三条边<span class="math inline">\(a、b、c\)</span>，如果<span class="math inline">\(a、b\)</span>确定了，那么我们只需要<span class="math inline">\(c\lt a + b\)</span>；那么我们枚举<span class="math inline">\(a、b\)</span>，求满足<span class="math inline">\(b\le c\lt a + b\)</span>的<span class="math inline">\(c\)</span>的个数，可以用树状数组，或者直接二分也可以；</p><h4 id="code-20">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">n = <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">l = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">int</span>, <span class="built_in">input</span>().<span class="built_in">split</span>()))</span><br><span class="line">l.<span class="built_in">sort</span>()</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(n - <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j in <span class="built_in">range</span>(i + <span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        pos = bisect.<span class="built_in">bisect_left</span>(l, l[i] + l[j])</span><br><span class="line">        ans += (pos - j - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, l[<span class="number">2003</span>], c[<span class="number">2003</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; <span class="number">2001</span>; i += i &amp; -i)</span><br><span class="line">        c[i] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= i &amp; -i)</span><br><span class="line">        res += c[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; l[i];</span><br><span class="line">    <span class="built_in">sort</span>(l + <span class="number">1</span>, l + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res += (<span class="built_in">sum</span>(<span class="number">2003</span>) - <span class="built_in">sum</span>(l[i]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(l[i] + l[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇博客记录下&lt;a href=&quot;https://atcoder.jp/home&quot;&gt;atcoder&lt;/a&gt;上的棕色难度的刷题记录；&lt;/p&gt;
&lt;h3 id=&quot;abc190-c---bowls-and-dishes&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc190/tasks/abc190_c&quot;&gt;ABC190 C - Bowls and Dishes&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;题解&quot;&gt;题解&lt;/h4&gt;
&lt;p&gt;这里由于&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;最大只有&lt;span class=&quot;math inline&quot;&gt;\(16\)&lt;/span&gt;，因此可以用暴力，这里使用二进制进行枚举，第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;位为0表示，选择将球放在&lt;span class=&quot;math inline&quot;&gt;\(C_i\)&lt;/span&gt;中，否则放在&lt;span class=&quot;math inline&quot;&gt;\(D_i\)&lt;/span&gt;中；之后判断&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(condition\)&lt;/span&gt;满足了多少个，然后更新最大值；&lt;/p&gt;</summary>
    
    
    
    <category term="Atcoder" scheme="https://chagelo.github.io/categories/Atcoder/"/>
    
    <category term="棕色" scheme="https://chagelo.github.io/categories/Atcoder/%E6%A3%95%E8%89%B2/"/>
    
    
    <category term="atcoder" scheme="https://chagelo.github.io/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>组合数学学习</title>
    <link href="https://chagelo.github.io/2021/03/23/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>https://chagelo.github.io/2021/03/23/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-23T12:03:17.000Z</published>
    <updated>2021-04-05T13:09:00.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计数问题">计数问题</h2><h3 id="t路计数">T路计数</h3><p>有一个这样的问题，一个<span class="math inline">\(n\times m\)</span>的矩形，从左上角走到右下角总共有多少种方法（只能往下或者右走），有两种方法求解，第一种用动态规划；第二种，左上走到右下共需要走<span class="math inline">\(m+n\)</span>中方法，从中选<span class="math inline">\(n\)</span>步往下走，则方法数为<span class="math inline">\(\displaystyle \tbinom{m+n}{n}\)</span>；</p><p>那么可能会有这样一种想法，如果按走马的方式来进行，我们只能<span class="math inline">\(dp\)</span>了；</p><span id="more"></span><h3 id="卡特兰数">卡特兰数</h3><p><span class="math display">\[C_n = \frac{(2n-2)!}{n!(n-1)!}\]</span></p><p>它表示，由<span class="math inline">\((0, 0)\)</span>到<span class="math inline">\((2n, 0)\)</span>，中途不经过<span class="math inline">\(x\)</span>轴且位于上半平面（下半平面）的<span class="math inline">\(\text{T}\)</span>路的条数；<span class="math inline">\(\text{T}\)</span>路由若干<span class="math inline">\(\text{T}\)</span>步（由<span class="math inline">\((x,y)\)</span>到<span class="math inline">\((x+1,y+1)\)</span>或<span class="math inline">\((x+1, y -1)\)</span>）组成；</p><h3 id="多少场球赛">多少场球赛</h3><p><span class="math inline">\(100\)</span>个球队进行比赛，每场比赛淘汰掉一队，问最终进行多少场比赛；每场淘汰<span class="math inline">\(1\)</span>队，<span class="math inline">\(100\)</span>队最终剩下<span class="math inline">\(1\)</span>队，所以是<span class="math inline">\(99\)</span>场比赛；</p><h3 id="反向思考">反向思考</h3><p>一个班级男生<span class="math inline">\(m\)</span>个，女生<span class="math inline">\(n\)</span>个，其中有一对双胞胎兄妹，现在需要从男生中选取一个班长，女生中选取一个团支书，并且不能同时选择该兄妹，问有多少种方法；</p><p>如果直接思考，需要分类讨论；可以这样，不考虑特殊约束共<span class="math inline">\(m\times n\)</span>种，特殊情况一种，那么总共<span class="math inline">\(m\times n - 1\)</span>种</p><h2 id="一些实际问题">一些实际问题</h2><ul><li>把<span class="math inline">\(r\)</span>件相同的物品分给<span class="math inline">\(n\)</span>个人的不同方法为<span class="math inline">\(C_{n+r-1}^{r}\)</span>；</li><li>把<span class="math inline">\(r\)</span>件相同的物品分给<span class="math inline">\(n(n\le r)\)</span>个人，使得每人至少分得一件物品的不同方法为<span class="math inline">\(C_{r-1}^{r-n}\)</span>，<strong>隔板法公式</strong>；</li><li>把<span class="math inline">\(6\)</span>本不同的书平均分为<span class="math inline">\(3\)</span>堆，分法为<span class="math inline">\(\frac{C_6^2C_4^2C_2^2}{A_3^3}\)</span></li><li><span class="math inline">\(6\)</span>本书分成<span class="math inline">\(3\)</span>堆，一份<span class="math inline">\(4\)</span>本，另外两份都是<span class="math inline">\(1\)</span>本，方法<span class="math inline">\(\frac{C_6^4C_2^1C_1^1}{A_2^2}\)</span></li><li>对于简单环形染色问题，要求相邻区域颜色不同，一般跳格分类讨论：<a href="https://www.bilibili.com/video/BV1Hy4y1h7VB">计数原理</a></li></ul><h2 id="排列">排列</h2><h3 id="圆排列">圆排列</h3><p><span class="math inline">\(n\)</span>个数字取<span class="math inline">\(r\)</span>个围成一个圆，问有多少种方法（圆平面内旋转圆得到的视为同一种）；将一个<span class="math inline">\(k\)</span>个元素的圆排列，从某个间隔位置分开得到一个线性排列共有<span class="math inline">\(k\)</span>种方法。也就是说一个圆排列对应<span class="math inline">\(k\)</span>种线性排列，那么<span class="math inline">\(A_n^r\)</span>种线性排列对应的圆排列k数为<span class="math inline">\(\frac{A_n^r}{r}\)</span>；</p><h3 id="项链排列">项链排列</h3><p>将一个圆排列翻转<span class="math inline">\(360\)</span>度得到的两种圆排列视为同一种；则项链排列数为<span class="math inline">\(\frac{A_n^r}{2r}(3\leq r\leq n )\)</span>；</p><h3 id="多重排列">多重排列</h3><p>将一个含有重复字母的字符串重排，共有多少种排列；</p><p>如<code>pingpang</code>，现在将同一种字母看成不同字母，求出排列数之后除以冗余度，那么<code>p1p2n1n2g1g2ia</code>，共<span class="math inline">\(\frac{8!}{2!2!2!}\)</span>种排列</p><p>若有<span class="math inline">\(n\)</span>个元素，<span class="math inline">\(r_1\)</span>个<span class="math inline">\(x_1\)</span>，<span class="math inline">\(r_2\)</span>个<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\dots{}r_t\)</span>个<span class="math inline">\(x_t\)</span>， 那么全排列数为<span class="math inline">\(\frac{n!}{r_1!r_2\dots r_t!}\)</span>；二项式定理前的系数可以按这种方式理解；</p><h3 id="隔板法">隔板法</h3><p><span class="math inline">\(6\)</span>个洞口，洞口每次只能进入一个乒乓球，一组编号为<span class="math inline">\(1\dots9\)</span>的<span class="math inline">\(9\)</span>个乒乓球滚入洞口的方案有多少；</p><p>这题很妙，用隔板法<span class="math inline">\(+\)</span>可重排列；</p><p>如果不考虑编号，那么直接使用隔板法；现在对于某种隔板的结果，我们可以把<span class="math inline">\(9\)</span>个编号分配给这些小球，那么就有<span class="math inline">\(9!\)</span>种分配法；</p><p>或者另外一种思路，将<span class="math inline">\(5\)</span>个隔板编号，共<span class="math inline">\(14\)</span>个元素全排，之后除以隔板的冗余度；</p><p>或者，先用隔板将区域划分好，然后往里面放有编号的小球，编号为<span class="math inline">\(1\)</span>的小球有<span class="math inline">\(6\)</span>种放法，编号为<span class="math inline">\(2\)</span>的小球有<span class="math inline">\(7\)</span>种，<span class="math inline">\(\dots\)</span></p><p><strong>看到这里，我不禁感叹，数学真的太棒了</strong>；</p><p>另外，解决这个问题的一个重要前提就是把给定的问题转换成数学模型；</p><p>对于分区域的问题，通常可以用隔板法解决；</p><h2 id="母函数">母函数</h2><p>对于一个序列<span class="math inline">\(C_0、C_1\dots C_n\)</span>，我们称<span class="math inline">\(G(x)=C_0 + C_1x^1+\dots +c_nx^n\)</span>为该序列的母函数；</p><p>假如我们有<span class="math inline">\(m\)</span>个骰子，对于<span class="math inline">\(m\)</span>个骰子的和，可以定义母函数<span class="math inline">\(G(x)=(x+x^2+x^3+x^4+x^5+x^6)^m\)</span>，其中<span class="math inline">\(x^k\)</span>前的系数表示骰子和为<span class="math inline">\(k\)</span>的骰子点数的可能情况数；</p><p>若有<span class="math inline">\(1、2、4、8、16、32\)</span>克的砝码，问能称出哪几种重量？有几种可能方案？</p><p><span class="math display">\[\begin{aligned} G(x) &amp;= (1 + x)(1 + x^2)(1 + x^4)(1 + x^8)(1 + x^{16})(1 +x^{32})\\                      &amp;=(1 + x + x^2 + \dots + x^{63})\\                      &amp;=\sum_{k=0}^{63}x^k\end{aligned}\]</span></p><p><span class="math inline">\(G\)</span>的每一项<span class="math inline">\((1+x^k)\)</span>表示选或者不选质量为<span class="math inline">\(k\)</span>的砝码；</p><p><strong>整数拆分</strong></p><p>若整数<span class="math inline">\(n\)</span>拆分成<span class="math inline">\(1、2、3\dots m\)</span>的和，并允许重复，求其母函数：</p><p><span class="math display">\[\begin{aligned} G_1(x) &amp; = (1 + x + x^2 + \dots)(1 + x^2 + x^4 + \dots)\dots (1 +x^m + x^{2m} + \dots)\\&amp; = \frac{1}{1-x} \frac{1}{1-x^2} \dots \frac{1}{1-x^m}\end{aligned}\]</span></p><p>其中<span class="math inline">\(G\)</span>的<span class="math inline">\((1+x^m+\dots)\)</span>表示数字<span class="math inline">\(m\)</span>选取的情况，我认为这里也可以考虑每个数字的选取情况（最多<span class="math inline">\(n\)</span>项，即每项都为1），那么</p><p><span class="math display">\[ G(x) = (1 + x + x^2 + \dots + x^m)\dots(1 + x + x^2 + \dots + x^m)\]</span></p><p>上面<span class="math inline">\(G(x)\)</span>共n项</p><h2 id="ref">ref</h2><p>1.https://www.bilibili.com/video/BV1vZ4y1j7gf?p=25&amp;spm_id_from=pageDriver</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计数问题&quot;&gt;计数问题&lt;/h2&gt;
&lt;h3 id=&quot;t路计数&quot;&gt;T路计数&lt;/h3&gt;
&lt;p&gt;有一个这样的问题，一个&lt;span class=&quot;math inline&quot;&gt;\(n\times m\)&lt;/span&gt;的矩形，从左上角走到右下角总共有多少种方法（只能往下或者右走），有两种方法求解，第一种用动态规划；第二种，左上走到右下共需要走&lt;span class=&quot;math inline&quot;&gt;\(m+n\)&lt;/span&gt;中方法，从中选&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;步往下走，则方法数为&lt;span class=&quot;math inline&quot;&gt;\(\displaystyle \tbinom{m+n}{n}\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;那么可能会有这样一种想法，如果按走马的方式来进行，我们只能&lt;span class=&quot;math inline&quot;&gt;\(dp\)&lt;/span&gt;了；&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="https://chagelo.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="组合数学" scheme="https://chagelo.github.io/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="组合数学" scheme="https://chagelo.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>How Bill Gates reads books</title>
    <link href="https://chagelo.github.io/2021/03/10/How-Bill-Gates-reads-books/"/>
    <id>https://chagelo.github.io/2021/03/10/How-Bill-Gates-reads-books/</id>
    <published>2021-03-10T04:01:17.000Z</published>
    <updated>2021-03-30T07:45:37.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="introduction">Introduction</h3><p>There is an interview about how Bill Gates reads books from Youtube.</p><span id="more"></span><h3 id="body">Body</h3><p>I don't let myself start a book that I'm not gonna finish.</p><ol type="1"><li>Take notes in the margins.</li></ol><p>You know when you're reading, you have to be careful that you really are concentrating, particularly if it's a non-fiction book. Are you taking the new knowledge and sort of attaching to knowledge you have?</p><p>And for me taking notes helps make sure that I'm really thinking hard about what's in there. If I disagree with the book sometimes, it takes a long time to read the book because I'm writing so much in the margin. It's actually kind of frustrating. Oh please say something I agree with. So I can get through to the end of this book.</p><ol start="2" type="1"><li>Don’t Start what you can’t finish.</li></ol><p>So there's this one it's a fiction book called Infinite Jest. I'm trying to decide if I started or not because I watched the movie, the end of the tour, I loved it. David Foster Wallace comes across as a super interesting, broad thinking person. If the book was like two or three-hundred-page book, there's no doubt as soon as I watched that movie, I dive in. But it's quite long and complicated and you know I don't want to make an exception. It's my rule to get to the end.</p><ol start="3" type="1"><li>Paper books &gt; ebooks.</li></ol><p>Over time I will make the switch, but when I'm just sitting there at night, reading often a paper magazine or the book I'm used to that and it's ridiculous because I have whole book bag that goes on my trips with me and it's voluminous and antiquated.</p><ol start="4" type="1"><li>Block out an hour.</li></ol><p>If you're reading books like these, you'd want to be sitting down for an hour at a time because otherwise just getting your mind around. okay what was I reading is not the kind of thing you can do five minutes here ten minutes there. Magazine articles and our short YouTube videos fit into those little slots. And so you know every night I'm reading a little over an hour and so I can take my current book and make some progress.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;There is an interview about how Bill Gates reads books from Youtube.&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://chagelo.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="阅读" scheme="https://chagelo.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>amazing tips and tricks in algorithms</title>
    <link href="https://chagelo.github.io/2021/03/08/amazing-tips-and-tricks-in-algorithms/"/>
    <id>https://chagelo.github.io/2021/03/08/amazing-tips-and-tricks-in-algorithms/</id>
    <published>2021-03-08T07:46:13.000Z</published>
    <updated>2021-03-10T04:16:44.075Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一些在算法中遇到的，令人感到非常惊奇的思路、技巧；</p><span id="more"></span><h3 id="无修改的区间和">无修改的区间和</h3><p>这个比较简单，前缀和；</p><h3 id="子数组的个数">子数组的个数</h3><p>如果给一个数组，让求数组中连续子数组的总个数，一个比较好的思路是：总的连续子数组的个数等于，以索引0结尾的子数组个数+以索引1结尾的子数组个数+...+以索引n-1结尾的子数组个数；同时，以索引i结尾的子数组的个数等于，以索引i-1结尾的子数组的个数再加个1（只含有下标i的一个元素的子数组），这里具有这样一种递推关系，但是仔细想一下，以索引i结尾的子数组个数不就等于i+1吗（共i+1个元素）；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里记录一些在算法中遇到的，令人感到非常惊奇的思路、技巧；&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://chagelo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="思维" scheme="https://chagelo.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
    <category term="算法" scheme="https://chagelo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>memset 原理</title>
    <link href="https://chagelo.github.io/2021/03/07/memset-%E5%8E%9F%E7%90%86/"/>
    <id>https://chagelo.github.io/2021/03/07/memset-%E5%8E%9F%E7%90%86/</id>
    <published>2021-03-07T07:44:02.000Z</published>
    <updated>2021-03-07T08:05:21.058Z</updated>
    
    <content type="html"><![CDATA[<p>算法竞赛中经常会使用memset来给数组赋值，有时候会发现给数组赋除<code>0、-1</code>外的其他值，似乎会产生一些错误；</p><p>从<a href="https://www.cplusplus.com/reference/cstring/memset/">c++官网</a>，我们可以得到<code>memset</code>的声明及解释；</p><p><code>void * memset ( void * ptr, int value, size_t num );</code>它的作用是：<code>Sets the first num bytes of the block of memory pointed by ptr to the specified value (interpreted as an unsigned char).</code></p><p>意思是将<code>ptr</code>指向的<code>num</code>个字节，用<code>value</code>来赋值，这个<code>value</code>被解释成<code>unsigned char</code>；</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(<span class="built_in">memset</span>)(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uc = c;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *su;</span><br><span class="line">    <span class="keyword">for</span> (su = s; <span class="number">0</span> &lt; n; ++su, --n)</span><br><span class="line">        *su = uc;</span><br><span class="line">    <span class="keyword">return</span> (s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是<code>memset</code>的源码；比如这段程序<code>memset(a, 1, sizeof(a));</code>，<code>a</code>是<code>int</code>型数组，在源码中，将整形1赋值给无符号<code>char</code>，那么就会截断整型，将低位的字节<code>0x01</code>赋值给<code>a</code>的每一个字节，<code>memset</code>中<code>a</code>被视为一个一个字节；因此最后得到的<code>a</code>中，每个<code>int</code>都是<code>0x01010101</code>；在程序中输出<code>memset</code>后的<code>a</code>中的元素，得到的值为<code>16843009</code>，它的十六进制也确实是<code>0x01010101</code>；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;算法竞赛中经常会使用memset来给数组赋值，有时候会发现给数组赋除&lt;code&gt;0、-1&lt;/code&gt;外的其他值，似乎会产生一些错误；&lt;/p&gt;
&lt;p&gt;从&lt;a href=&quot;https://www.cplusplus.com/reference/cstring/memset/&quot;&gt;c++官网&lt;/a&gt;，我们可以得到&lt;code&gt;memset&lt;/code&gt;的声明及解释；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void * memset ( void * ptr, int value, size_t num );&lt;/code&gt;它的作用是：&lt;code&gt;Sets the first num bytes of the block of memory pointed by ptr to the specified value (interpreted as an unsigned char).&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;意思是将&lt;code&gt;ptr&lt;/code&gt;指向的&lt;code&gt;num&lt;/code&gt;个字节，用&lt;code&gt;value&lt;/code&gt;来赋值，这个&lt;code&gt;value&lt;/code&gt;被解释成&lt;code&gt;unsigned char&lt;/code&gt;；&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="https://chagelo.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="c++" scheme="https://chagelo.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>离散数学 命词逻辑</title>
    <link href="https://chagelo.github.io/2021/02/02/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E5%90%8D%E8%AF%8D%E9%80%BB%E8%BE%91/"/>
    <id>https://chagelo.github.io/2021/02/02/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E5%90%8D%E8%AF%8D%E9%80%BB%E8%BE%91/</id>
    <published>2021-02-02T03:22:26.000Z</published>
    <updated>2021-02-02T04:42:54.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命词逻辑">命词逻辑</h3><ol type="1"><li>否定联结词</li><li>合取联结词</li><li>析取联结词</li><li>蕴含联结词<span class="math inline">\(P\rightarrow Q\)</span></li><li>等价联结词</li></ol><p>五个联结词优先顺序为：否定、合区、析取、蕴含、等价；</p><span id="more"></span><p>比如<code>雪是白的当且仅当北京是中国的首都</code>，这是一个等价命题，其中<code>雪是白的</code>是真命题，<code>北京是中国的首都</code>也是真命题，因此这个命题是一个真命题；虽然两个自命题之间没有联系；</p><p>而对<code>如果2是偶数，则天上会吊馅饼</code>，这是一个蕴含命题，<code>2是偶数</code>是真值为真的前件，<code>天上掉馅饼</code>是真值为假的后件，由蕴含命题的特性，这个命题的真值是假；</p><p>因此，<strong>一个复合命题的真值只取决于其中的原子命题的真值，而与具体的命题内容无关。</strong></p><h4 id="命题变元">命题变元</h4><p>当复合命题中的原子命题是变元时，此复合命题也为命题变元的函数，可称为“真值函数”或“命题公式”；如：</p><p><span class="math display">\[G = P \vee Q \rightarrow \lnot R\]</span></p><h4 id="命题公式">命题公式</h4><p>原子命题 <span class="math inline">\(P,Q,R\)</span> 是最简单的命题公式；</p><p>实际应用时，常用二元树表达命题公式</p><h4 id="真值表">真值表</h4><p>由公式在其所有可能的解释（也就是原子命题所有取值可能的组合）下所取真值构成的表，成为真值表；</p><h4 id="命题公式分类">命题公式分类</h4><ul><li>永真公式，也叫做<strong>重言式</strong>；</li><li>永假公式，有时也称永假公式为不可满足公式，或<strong>矛盾式</strong>；</li><li>一个公式是可满足公式，如果他不是永假的；</li></ul><h4 id="基本等价公式">基本等价公式</h4><p>这里只写出一些不好写的公式蕴含式</p><ol type="1"><li>蕴含式：<span class="math inline">\(G\rightarrow H = \lnot G\wedge H\)</span></li><li>假言易式：<span class="math inline">\(G\rightarrow H = \lnot H \rightarrow \lnot G\)</span></li><li>等价否定式：<span class="math inline">\(G\iff H = \lnot G \iff \lnot H\)</span></li><li>归谬式：<span class="math inline">\((G\rightarrow H) \vee (G\rightarrow \lnot H) = \lnot G\)</span></li></ol><h3 id="范式">范式</h3><p><strong>定义</strong></p><ul><li><p>命题变元或命题变元的否定成为<strong>文字</strong>，<span class="math inline">\(P,\lnot P,Q,\lnot Q \dots\)</span></p></li><li><p>有限个文字的析取称为简单析取式</p></li><li><p>有限个文字的合取称为简单合取式</p></li><li><p>有限个简单合取式的析取式称为析取范式，特例 <span class="math inline">\(P\vee \lnot Q,P,\lnot P\)</span></p></li><li><p>有限个简单析取式的合取式称为合取范式，特例 <span class="math inline">\(P\wedge \lnot Q,P,\lnot P\)</span></p></li></ul><p>如<span class="math inline">\(P\vee Q \vee \lnot R\)</span>既是合取范式又是析取范式，但<span class="math inline">\((P\vee Q \vee \lnot R)\)</span>，是析取范式，里面的<span class="math inline">\(P,Q,R\)</span>不能分别看作一个个体；</p><h4 id="范式存在定理">范式存在定理</h4><ol type="1"><li>单个的文字是子句、短语、析取范式、合取范式；</li><li>析取范式、合取范式仅含联结词 <span class="math inline">\(\{\lnot ,\vee ,\wedge \}\)</span>，且否定联结词仅出现在命题变元之前</li></ol><p>如果命题公式中出现蕴含等价，都可以通过公式转化，使其只含非、合取、析取联结词，转换为与其等价的析取范式和合取范式，如：<span class="math inline">\(G\iff H = \lnot G\wedge H\)</span></p><h4 id="极小项与极大项">极小项与极大项</h4><p>极小项对应合取范式，命题变元为1，命题变元的非为0；即让极小项为真的编码，只有一组； 极大项对应析取范式，规则相反，命题变元为0，命题变元的非为1；即让极大项为假的编码，也只有一组；</p><p><img src = "/images/极小项与极大项.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;命词逻辑&quot;&gt;命词逻辑&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;否定联结词&lt;/li&gt;
&lt;li&gt;合取联结词&lt;/li&gt;
&lt;li&gt;析取联结词&lt;/li&gt;
&lt;li&gt;蕴含联结词&lt;span class=&quot;math inline&quot;&gt;\(P\rightarrow Q\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;等价联结词&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;五个联结词优先顺序为：否定、合区、析取、蕴含、等价；&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://chagelo.github.io/categories/Note/"/>
    
    <category term="离散数学" scheme="https://chagelo.github.io/categories/Note/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="note" scheme="https://chagelo.github.io/tags/note/"/>
    
    <category term="基础学科" scheme="https://chagelo.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"/>
    
  </entry>
  
  <entry>
    <title>离散数学 集合论</title>
    <link href="https://chagelo.github.io/2021/02/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E9%9B%86%E5%90%88%E8%AE%BA/"/>
    <id>https://chagelo.github.io/2021/02/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E9%9B%86%E5%90%88%E8%AE%BA/</id>
    <published>2021-02-01T04:57:34.000Z</published>
    <updated>2021-02-02T03:24:37.952Z</updated>
    
    <content type="html"><![CDATA[<p>{1}</p><h2 id="集合">集合</h2><p>集合中的元素可以是任何对象</p><h3 id="集合表示">集合表示</h3><ol type="1"><li>枚举法</li><li>叙述法：具有某种性质的元素</li><li>文氏图</li></ol><h3 id="集合基数">集合基数</h3><ol type="1"><li>集合A中的元素的个数是|A|；</li><li>若一个集合的基数是有限的，则该集合为有限集</li><li>若一个集合的基数是无限的，则称该集合为无限集</li></ol><p><span class="math display">\[A = {a,b,c},|A| = 3\]</span></p><p><span class="math display">\[B = {a,{b,c}},|B| = 2\]</span></p><h3 id="空集">空集</h3><p>空集是唯一的</p><p><span class="math inline">\(|\emptyset| = 0,|{\emptyset}| = 1\)</span></p><h3 id="全集">全集</h3><p>全集在文氏图中一般用方形表示；</p><h3 id="元素的基本特性">元素的基本特性</h3><ol type="1"><li>集合中的元素是无序的，<span class="math inline">\(\{1,2,3,4\}\)</span>与<span class="math inline">\(\{2,3,1,4\}\)</span>相同</li><li>集合中的元素是不同的，<span class="math inline">\(\{1,2,2,3,4,3,4,2\}\)</span>与<span class="math inline">\(\{1,2,3,4\}\)</span>相同</li></ol><p><strong>外延性原理</strong></p><p>两个集合<span class="math inline">\(A,B\)</span>相等，当且仅当他们的元素完全相同，记<span class="math inline">\(A=B\)</span>，否则<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>不相同，记作<span class="math inline">\(A\neq B\)</span>；</p><p><strong>定理</strong></p><p>设<span class="math inline">\(A,B\)</span>为任意两个集合，则<span class="math inline">\(A=B\iff A\subseteq B,B\subseteq A\)</span></p><p>证明两个集合相等，证明<span class="math inline">\(A\subseteq B\)</span>同时<span class="math inline">\(B\subseteq A\)</span></p><p><strong>幂集</strong></p><p><span class="math inline">\(A\)</span>为任意集合，把A的所有不同子集构成的集合叫做A的幂集，记作<span class="math inline">\(P(A)\)</span></p><p>比如<span class="math inline">\(A = \{a,\{b,c\}\}\)</span>，<span class="math inline">\(P(A)=\{\emptyset, \{a\}, \{b,c\},\{a,\{b,c\}\}\}\)</span></p><h3 id="集合的运算">集合的运算</h3><ol type="1"><li>并集</li><li>交集</li><li>补集，设<span class="math inline">\(U\)</span>是全集，则集合<span class="math inline">\(A\)</span>的补集定义为：<span class="math inline">\(\overline A = \{x|x\notin A\}\)</span></li><li>差集</li><li>对称差，<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>的对称差就是只属于<span class="math inline">\(A\)</span>的和只属于<span class="math inline">\(B\)</span>的元素的并</li></ol><p><strong>运算定律</strong></p><ol type="1"><li>幂等律：<span class="math inline">\(A\cup A \cup ... A= A,A\cap A \cap ... A= A\)</span></li><li>同一律：<span class="math inline">\(A\cup \emptyset = A ,A\cap U = A\)</span></li><li>零律： <span class="math inline">\(A\cup U = U, A\cap \emptyset = \emptyset\)</span></li><li>德摩根律，交换律，结合律，分配律</li></ol><p><img src ="/images/德摩根律.png"></p><h3 id="不可数集合与可数集合">不可数集合与可数集合</h3><p>如何比较集合的大小，对于两个有限集合，只需要比较集合的基数；</p><p><strong>等势</strong></p><p>如果两个集合的所有元素具有一种相互的一一映射关系，那么两个集合是等势的；</p><p><strong>可数集合</strong></p><p>凡是与自然数集合<span class="math inline">\(\text{N}\)</span>等势的集合，成为可数集合（countable set）</p><p>正奇数集合、素数集合、有理数集合都是可数集合</p><p>正奇数集合、素数集合是自然数集合的子集，然而它们是与自然数集合是等势的，而有理数集合元素比自然数集合多得多，它们仍然是等势的；</p><p>因此我们可以意识到，两个无限集合的“大小”已经不能单纯使用集合中的元素个数来衡量。<span class="math inline">\(aleph_0\)</span>表示一切可数集合的基数，是一种抽象的表达；</p><p><strong>不可数集合</strong></p><p>开区间<span class="math inline">\((0,1)\)</span>称不可数集合，凡是与<span class="math inline">\((0,1)\)</span>等势的集合成为不可数集合，该类集合的基数为<span class="math inline">\(\aleph\)</span></p><p>实数集合是不可数集合</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;{1}&lt;/p&gt;
&lt;h2 id=&quot;集合&quot;&gt;集合&lt;/h2&gt;
&lt;p&gt;集合中的元素可以是任何对象&lt;/p&gt;
&lt;h3 id=&quot;集合表示&quot;&gt;集合表示&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;枚举法&lt;/li&gt;
&lt;li&gt;叙述法：具有某种性质的元素&lt;/li&gt;
&lt;li&gt;文氏图</summary>
      
    
    
    
    <category term="Note" scheme="https://chagelo.github.io/categories/Note/"/>
    
    <category term="离散数学" scheme="https://chagelo.github.io/categories/Note/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="note" scheme="https://chagelo.github.io/tags/note/"/>
    
    <category term="基础学科" scheme="https://chagelo.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"/>
    
  </entry>
  
  <entry>
    <title>Primer 变量与基本数据类型</title>
    <link href="https://chagelo.github.io/2021/01/31/Primer-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://chagelo.github.io/2021/01/31/Primer-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-01-31T06:23:20.000Z</published>
    <updated>2021-02-01T08:20:50.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本内置类型">基本内置类型</h3><h4 id="含无符号类型的表达式">含无符号类型的表达式</h4><p>隐式类型转换顺序：</p><p><img src ="/images/类型转换.bmp" width = 550px></p><p><strong>如果表达式中既有带符号类型和无符号类型，带符号数会自动转换为无符号类型；</strong></p><span id="more"></span><h4 id="字面值常量">字面值常量</h4><p><code>'a'</code>：字符字面值，<code>hi</code>：字符串字面值</p><p><code>20</code>十进制，<code>024</code>八进制，<code>0xff</code>十六进制，<code>\x4d</code>和<code>\77</code>均表示<code>M</code></p><p>指定常量的类型：</p><table><thead><tr class="header"><th>前缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr class="odd"><td>u</td><td>unicode16字符</td><td>char16_t</td></tr><tr class="even"><td>U</td><td>unicode32字符</td><td>char32_t</td></tr><tr class="odd"><td>L</td><td>宽字符</td><td>wchar_t</td></tr><tr class="even"><td>u8</td><td>utf-8</td><td>char</td></tr></tbody></table><table><thead><tr class="header"><th>整形字面值</th><th></th><th>浮点型字面值</th><th>"</th></tr></thead><tbody><tr class="odd"><td>后缀</td><td>最小匹配类型</td><td>后缀</td><td>类型</td></tr><tr class="even"><td>u,U</td><td>unsigned</td><td>f,F</td><td>float</td></tr><tr class="odd"><td>l,L</td><td>long</td><td>l,L</td><td>long double</td></tr><tr class="even"><td>ll,LL</td><td>long long</td><td></td><td></td></tr></tbody></table><blockquote><p>L'a' //宽字符型 u8"hi!" //utf-8 1E-3F //float 3.14 //long double</p></blockquote><h3 id="变量">变量</h3><h4 id="列表初始化">列表初始化</h4><p>使用花括号来初始化成为列表初始化；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;; <span class="comment">//下面三个为列表初始化</span></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果使用列表初始化且初始值存在丢失信息的风险，则编译器会报错；但是，使用普通的列表初始化并不会出错；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> b = &#123;&#125;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h4 id="分离式编译">分离式编译</h4><p>C++语言允许分离式编译，该机制允许将程序分割为若干个文件每个文件可被独立编译；</p><h4 id="声明与定义">声明与定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;   <span class="comment">//声明i而非定义</span></span><br><span class="line"><span class="keyword">int</span> i;          <span class="comment">//声明并定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">10</span>;<span class="comment">//定义</span></span><br></pre></td></tr></table></figure><p>extern语句若包含初始值也就变成了定义</p><h4 id="引用">引用</h4><p>引用必须被初始化，<code>int &amp;a</code>是错误的，定义引用时，程序把引用和它的初始值一直绑定在一起，一旦初始化完成，引用和它的初始化值对象一直绑定在一起，；<strong>因为无法令引用重新绑定到另外一个对象，因此引用必须初始化；</strong></p><p><strong>引用本身不是一个对象，因此不能定义引用的引用；</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;val1 = <span class="number">10</span>; <span class="comment">//错误，引用类型的初始值必须是一个对象，这个非常关键</span></span><br><span class="line"><span class="keyword">double</span> val2 = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;val3 = val2;   <span class="comment">//错误，类型不匹配</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">027</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 23 23</span></span><br><span class="line">    b = c;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 10 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="int-与int">int *&amp; 与int &amp;*</h4><p>从内往外看，<code>int *&amp;</code>定义的是指针的引用，<code>int &amp;*</code>定义的是引用的指针，而引用又不是对象，因此没有指针；所以第二种写法严格来说是错误的；</p><h4 id="void">void *</h4><p><code>void *</code>是一种特殊的指针类型，可用于存放任何对象的地址，因此对于它的地址中存放着一个什么类型的对象是不知道的；</p><p>并且以<code>void *</code>视角访问内存，只能访问到地址，而不能访问到具体地址的对象；</p><p>令注：<strong>在c++/c中进行指针类型转换不是一件随便的事情</strong>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 下面这条语句是非法的</span></span><br><span class="line"><span class="comment">//long *lp = (long *)&amp;i</span></span><br><span class="line"><span class="keyword">long</span> *lp = &amp;i;</span><br></pre></td></tr></table></figure><h3 id="const">const</h3><p><code>const</code>对象必须进行初始化；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这条语句是错误的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;</span><br></pre></td></tr></table></figure><p><code>const</code>类型的对象只能执行不改变其内容的操作；如算数运算，转换成一个布尔值；</p><h4 id="const与初始化">const与初始化</h4><p>如果用一个对象去初始化另一个对象，则它们是不是<code>const</code>都无所谓；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 下面两条语句都是合法的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;   <span class="comment">// 拷贝</span></span><br><span class="line"><span class="keyword">int</span> j = i;          <span class="comment">// 拷贝</span></span><br></pre></td></tr></table></figure><p><code>ci</code>的<code>const</code>特征仅仅在执行修改它的操作时才发挥作用；</p><h4 id="const的引用">const的引用</h4><p>可以把引用绑定到<code>const</code>上；对<code>const</code>的引用常称为“常量引用”；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;</span><br><span class="line">r1 = <span class="number">42</span>;        <span class="comment">// r1 是对常量的引用，不能修改，错误</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci    <span class="comment">// 非常量引用绑定常量上，错误</span></span><br></pre></td></tr></table></figure><p>虽然非常量引用不允许绑定到常量上，但是常量引用允许绑定到非常量上</p><p><strong>初始化与对 const 的引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure><p>上面两条语句其实本质是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure><p>下面两条语句是错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = r1 * <span class="number">2</span>;    <span class="comment">//非常量引用不允许绑定到常量上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两条语句也是错的</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = a * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = temp;  <span class="comment">//非常量引用显然不允许绑定到常量上，因此错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这两条语句是对的</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;d = c;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>非 const 与 const 引用同时绑定</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;</span><br><span class="line">r1 = <span class="number">0</span>;     <span class="comment">// 正确</span></span><br><span class="line">r2 = <span class="number">0</span>;     <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h4 id="const-与指针">const 与指针</h4><p>与引用相似，要存放一个 <code>const</code> 类型变量的地址，只能用指向 <code>const</code> 类型变量的指针；但是指向常量的指针没有规定其所指对象必须是常量；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *cosnt p1 = &amp;num;   <span class="comment">//p1 只能指向 num，不能改变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;pi;    <span class="comment">// p2指向一个常量</span></span><br></pre></td></tr></table></figure><h4 id="constexpr">constexpr</h4><p>声明为 <code>constexpr</code> 的变量一定是一个常量，而且必须用常量表达式初始化；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;  <span class="comment">// 20 是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>;   <span class="comment">// mf + 1 是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>(); <span class="comment">// 只有size()是 constexpr 函数时，才是正确的语句，即使size()返回值是  常数也不行；</span></span><br></pre></td></tr></table></figure><p>对于 <code>constexpr</code> 的声明中，它仅对指针有效，对指针所指对象无关；</p><h4 id="null与nullptr">null与nullptr</h4><p>首先需要明确， <code>null</code> 是无类型的，而 <code>nullptr</code> 是 <code>nullptr_t</code> 类型的；</p><p>在c++中不能将<code>void *</code>类型转换成其他类型，在c++中，在stddef.h中<code>null</code>是这样定义的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基本内置类型&quot;&gt;基本内置类型&lt;/h3&gt;
&lt;h4 id=&quot;含无符号类型的表达式&quot;&gt;含无符号类型的表达式&lt;/h4&gt;
&lt;p&gt;隐式类型转换顺序：&lt;/p&gt;
&lt;p&gt;&lt;img src =&quot;/images/类型转换.bmp&quot; width = 550px&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果表达式中既有带符号类型和无符号类型，带符号数会自动转换为无符号类型；&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://chagelo.github.io/categories/c/"/>
    
    <category term="primer note" scheme="https://chagelo.github.io/categories/c/primer-note/"/>
    
    
    <category term="C++" scheme="https://chagelo.github.io/tags/C/"/>
    
    <category term="c++ pirmer" scheme="https://chagelo.github.io/tags/c-pirmer/"/>
    
  </entry>
  
  <entry>
    <title>序列自动机</title>
    <link href="https://chagelo.github.io/2021/01/24/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>https://chagelo.github.io/2021/01/24/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/</id>
    <published>2021-01-24T08:22:45.000Z</published>
    <updated>2021-01-24T09:02:55.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目">题目</h4><p><a href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列</a></p><h4 id="题意">题意</h4><ol type="1"><li><p>给定字符串<span class="math inline">\(s\)</span>、<span class="math inline">\(t\)</span>，判断<span class="math inline">\(s\)</span>是否为<span class="math inline">\(t\)</span>的子序列；</p></li><li><p>给定字符串<span class="math inline">\(s_1,s_2,\dots\)</span>，依次判断他们是否是<span class="math inline">\(t\)</span>的子序列；</p></li></ol><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(0\leq |s| \leq 100, 0\leq |t| \leq 10000\)</span></p><span id="more"></span><h4 id="题解">题解</h4><p>对于第一个问题，显然暴力就行；</p><p>对于第二个问题；注意到，如果对于<span class="math inline">\(s[i]\)</span>和<span class="math inline">\(t[j]\)</span>相同，那么我们只能在<span class="math inline">\(t\)</span>中位置<span class="math inline">\(j\)</span>之后找与<span class="math inline">\(s[i+1]\)</span>相同的字符，并且我们应该贪心的，在<span class="math inline">\(t\)</span>中位置<span class="math inline">\(j\)</span>后面的字符中，找尽可能在前面的与<span class="math inline">\(s[i+1]\)</span>匹配的字符，以此让后面的字符有更多机会匹配成功；</p><p>这就需要我们统计，第<span class="math inline">\(i\)</span>个字符后面的第一个<code>a ~ z</code>，这就需要通过序列自动机来实现，本质上也就是<span class="math inline">\(dp\)</span>；</p><h4 id="code">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">10004</span>][<span class="number">30</span>];</span><br><span class="line">        <span class="keyword">int</span> ts = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ss = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">        <span class="comment">// 序列自动机</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ts - <span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)&#123;</span><br><span class="line">                f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][t[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss; i++)</span><br><span class="line">            <span class="keyword">if</span> (f[l][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> l = f[l][s[i] - <span class="string">&#x27;a&#x27;</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;题目&quot;&gt;题目&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/is-subsequence/&quot;&gt;392. 判断子序列&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;题意&quot;&gt;题意&lt;/h4&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;给定字符串&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，判断&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;是否为&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;的子序列；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给定字符串&lt;span class=&quot;math inline&quot;&gt;\(s_1,s_2,\dots\)&lt;/span&gt;，依次判断他们是否是&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;的子序列；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;数据范围&quot;&gt;数据范围&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(0\leq |s| \leq 100, 0\leq |t| \leq 10000\)&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://chagelo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="dp" scheme="https://chagelo.github.io/categories/%E7%AE%97%E6%B3%95/dp/"/>
    
    
    <category term="dp" scheme="https://chagelo.github.io/tags/dp/"/>
    
    <category term="leetcode" scheme="https://chagelo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="https://chagelo.github.io/2021/01/23/git%E4%BD%BF%E7%94%A8/"/>
    <id>https://chagelo.github.io/2021/01/23/git%E4%BD%BF%E7%94%A8/</id>
    <published>2021-01-23T09:55:35.000Z</published>
    <updated>2021-04-30T02:03:28.692Z</updated>
    
    <content type="html"><![CDATA[<p><strong>git配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前项目git配置</span></span><br><span class="line">git config -l</span><br><span class="line"><span class="comment"># 查看系统配置</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="comment"># 查看本地配置</span></span><br><span class="line">git config --global --list</span><br><span class="line"><span class="comment"># 配置邮箱、用户名</span></span><br><span class="line">git config --global user.name <span class="string">&quot;chagelo&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;example@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>git操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span>  <span class="string">&quot;远程仓库地址&quot;</span> <span class="comment">#克隆远程仓库到本地</span></span><br><span class="line">git add .               <span class="comment">#添加修改到stage</span></span><br><span class="line">git commit -m <span class="string">&quot;备注信息&quot;</span>   <span class="comment">#提交到local resp</span></span><br><span class="line">git push origin master  <span class="comment">#提交到master</span></span><br><span class="line">git push origin chagelo:chagelo     <span class="comment">#提交本地chagelo分支到远程分支chagelo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并将这次删除操作放入暂存区</span></span><br><span class="line">git rm (file1) (file2)...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改文件名称，并把这次操作放入暂存区</span></span><br><span class="line">git mv (file-original) (file-renamed)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>git分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地所有分支</span></span><br><span class="line">git branch </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程所有分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d (branchname)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但仍然停留在当前分支</span></span><br><span class="line">git branch (branchname)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支并切换到该分支</span></span><br><span class="line">git checkout -b (branchname)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到另一个分支</span></span><br><span class="line">git checkout (branchname)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2021/4/15</p><p>刚刚在github上创建了一个rep，发现默认分支由master变成了main，已经clone到了本地（本地显示的也是main），这时候去修改了github<code>setting</code>里的default branch名为master，但是本地分支还是main；</p><p>解决办法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -m main master</span><br><span class="line">git fetch origin</span><br><span class="line">git branch -u origin/master master</span><br><span class="line">git remote set-head origin -a</span><br></pre></td></tr></table></figure><p><strong>删除master分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除本地master分支</span></span><br><span class="line">git branch -d master</span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin :master</span><br></pre></td></tr></table></figure><p>2021/4/26</p><p>git如何忽略已提交的文件(.gitignore无效)</p><p><code>git status</code>可以查看cached的列表，即修改列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只让某个文件或者文件夹处于不被track的状态，执行下面语句，之后将文件夹或者文件加入忽略文件中</span></span><br><span class="line">git rm -r --cached 需要忽略的文件/文件夹</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>[1] <a href="https://www.bilibili.com/video/BV1FE411P7B3?p=1">狂神说git</a></p><p>[2] <a href="https://gitee.com/all-about-git">Git 大全</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;git配置&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 查看当前项目git配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 查看系统配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --system --list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 查看本地配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global --list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 配置邮箱、用户名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &lt;span class=&quot;string&quot;&gt;&amp;quot;chagelo&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email &lt;span class=&quot;string&quot;&gt;&amp;quot;example@gmail.com&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="git" scheme="https://chagelo.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://chagelo.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 树 简单题</title>
    <link href="https://chagelo.github.io/2021/01/21/leetcode-%E6%A0%91/"/>
    <id>https://chagelo.github.io/2021/01/21/leetcode-%E6%A0%91/</id>
    <published>2021-01-21T04:53:23.000Z</published>
    <updated>2021-01-24T06:17:02.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="n叉的前序遍历"><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N叉的前序遍历</a></h3><h4 id="code">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;children.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> child:root-&gt;children) &#123;</span><br><span class="line">                <span class="built_in">preorder</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="递增顺序查找树"><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h3><h4 id="code-1">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* temp;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        temp = res;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode * l = root-&gt;left;</span><br><span class="line">            TreeNode * r = root-&gt;right;</span><br><span class="line">            <span class="built_in">dfs</span>(l);</span><br><span class="line">            temp-&gt;right = root;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            temp = temp-&gt;right;</span><br><span class="line">            <span class="built_in">dfs</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-offer-54.-二叉搜索树的第k大节点"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3><h4 id="code-2">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> vec[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树"><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><h4 id="code-3">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root) &gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h_l = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> h_r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (h_r  == <span class="number">-1</span> || h_l == <span class="number">-1</span> || <span class="built_in">abs</span>(h_l - h_r) &gt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(h_l,h_r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径总和"><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><h4 id="code-4">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> flag, cnt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        cnt+= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == targetSum) flag = <span class="number">1</span>;</span><br><span class="line">            cnt-= root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,targetSum);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,targetSum);</span><br><span class="line">        cnt-= root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方题解bfs；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode *&gt; que_node;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que_val;</span><br><span class="line">        que_node.<span class="built_in">push</span>(root);</span><br><span class="line">        que_val.<span class="built_in">push</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span> (!que_node.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *now = que_node.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">int</span> temp = que_val.<span class="built_in">front</span>();</span><br><span class="line">            que_node.<span class="built_in">pop</span>();</span><br><span class="line">            que_val.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left == <span class="literal">nullptr</span> &amp;&amp; now-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;left);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;left-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que_node.<span class="built_in">push</span>(now-&gt;right);</span><br><span class="line">                que_val.<span class="built_in">push</span>(now-&gt;right-&gt;val + temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="从根到叶的二进制数之和"><a href="https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/">1022. 从根到叶的二进制数之和</a></h3><h4 id="code-5">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            ans += (cnt * <span class="number">2</span> + root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, cnt * <span class="number">2</span> + root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, cnt * <span class="number">2</span> + root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和上一题类似，显然这题也可以用bfs</p><h3 id="根据二叉树创建字符串"><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串</a></h3><h4 id="code-6">code</h4><p>这题有点垃圾，题意含糊不清；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">dfs</span>(t);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * t)</span></span>&#123;</span><br><span class="line">        res = res + <span class="built_in">to_string</span>(t-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left)  &#123;</span><br><span class="line">            res += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(t-&gt;left);</span><br><span class="line">            res += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t-&gt;left) res += <span class="string">&quot;()&quot;</span>;</span><br><span class="line">            res += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(t-&gt;right);</span><br><span class="line">            res += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并二叉树"><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><h4 id="code-7">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t1)<span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(!t2)<span class="keyword">return</span> t1;</span><br><span class="line">        <span class="built_in">dfs</span>(t1,t2);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 &amp;&amp; t2) &#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">            <span class="built_in">dfs</span>(t1-&gt;left,t2-&gt;left);</span><br><span class="line">            <span class="built_in">dfs</span>(t1-&gt;right,t2-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (!t1-&gt;left &amp;&amp; t2-&gt;left)</span><br><span class="line">                t1-&gt;left = t2-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (!t1-&gt;right &amp;&amp; t2-&gt;right)</span><br><span class="line">                t1-&gt;right = t2-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最大深度"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><h4 id="code-8">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">dfs</span>(root-&gt;left),<span class="built_in">dfs</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然还可以用bfs求；</p><h3 id="二叉树的层序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><h4 id="code-9">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;temp1;</span><br><span class="line">        queue&lt;TreeNode *&gt;temp2;</span><br><span class="line">        temp2.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!temp2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            temp1.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">int</span> cnt = temp2.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                TreeNode * temp = temp2.<span class="built_in">front</span>();</span><br><span class="line">                temp2.<span class="built_in">pop</span>();</span><br><span class="line">                temp1.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left) &#123;</span><br><span class="line">                    temp2.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right)&#123;</span><br><span class="line">                    temp2.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (dep &gt; res.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span> &gt; <span class="title">temp</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        res[dep<span class="number">-1</span>].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, dep + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历-ii"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (dep &gt; res.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span> &gt; <span class="title">temp</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        res[dep<span class="number">-1</span>].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, dep + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="翻转二叉树"><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><h4 id="code-10">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的最近公共祖先"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><h4 id="code-11">code</h4><p>官方题解，需要注意这是一颗二叉搜索树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode *res = root;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; res-&gt;val &amp;&amp; q-&gt;val &lt; res-&gt;val) &#123;</span><br><span class="line">                res = res-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; res-&gt;val &amp;&amp; q-&gt;val &gt; res-&gt;val) &#123;</span><br><span class="line">                res = re-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="相同的树"><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h3><h4 id="code-12">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; q || !q &amp;&amp; p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left,q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的最小绝对差"><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><h4 id="code-13">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxm = <span class="number">0x3f3f3f</span>, temp = maxm;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        maxm = <span class="built_in">min</span>(maxm,<span class="built_in">abs</span>(temp - root-&gt;val));</span><br><span class="line">        temp = root-&gt;val;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="左叶子之和"><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><h4 id="code-14">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)<span class="keyword">return</span> ;</span><br><span class="line">        TreeNode* rl = root-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (rl &amp;&amp; !rl-&gt;left &amp;&amp; !rl-&gt;right) res += rl-&gt;val;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单值二叉树"><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">965. 单值二叉树</a></h3><h4 id="code-15">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        val = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left) &amp;&amp; <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="修剪二叉搜索树"><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/submissions/">669. 修剪二叉搜索树</a></h3><p>这里注意引用的使用，<strong>引用和指针是不一样的</strong>；把dfs函数里的*、&amp;改成*就错了；</p><h4 id="code-16">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* &amp;root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">dfs</span>(root,low,high);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; high) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">dfs</span>(root,low,high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left,low,high);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的堂兄弟节点"><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h3><h4 id="code-17">code</h4><p>啊啊啊，看我这丑陋的代码，太糟糕了；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre_x,pre_y;</span><br><span class="line">        queue&lt;TreeNode *&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            pre_x = pre_y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode * temp = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                TreeNode *rl = temp-&gt;left;</span><br><span class="line">                TreeNode *rr = temp-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (rl) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(rl);</span><br><span class="line">                    <span class="keyword">if</span> (rl-&gt;val == x)</span><br><span class="line">                        pre_x = temp-&gt;val;</span><br><span class="line">                    <span class="keyword">if</span> (rl-&gt;val == y) </span><br><span class="line">                        pre_y = temp-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rr) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(rr);</span><br><span class="line">                    <span class="keyword">if</span> (rr-&gt;val == x)</span><br><span class="line">                        pre_x = temp-&gt;val;</span><br><span class="line">                    <span class="keyword">if</span> (rr-&gt;val == y)</span><br><span class="line">                        pre_y = temp-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre_x != pre_y &amp;&amp; pre_x!=<span class="number">0</span> &amp;&amp; pre_y!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两数之和-iv---输入-bst"><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h3><h4 id="code-18">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode * root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">count</span>(k - root-&gt;val))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">insert</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left, k) || <span class="built_in">dfs</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的直径"><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><h4 id="code-19">code</h4><p>dfs版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        res = <span class="built_in">max</span>(res, l + r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树中第二小的节点"><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h3><h4 id="题解">题解</h4><p>对于这颗特殊的二叉树，需要求第二小的数；</p><p>由题意，根一定是最小的，记录下根的数值<span class="math inline">\(a\)</span>，搜索这棵树，找满足大于<span class="math inline">\(a\)</span>的最小值；</p><p>一开始思路错了，其实如果在搜索过程中把子树的最小值返回也是一样的，如果根的两个子树的最小值相同，那就需要递归的到两颗子树里面找；</p><p>注意下面代码的第三行<code>minm = 1ll &lt;&lt; 32</code>，因为<code>minm</code>是<code>long long</code>，如果是<code>int</code>，左移最多只能进行31次，否则会报错；因此需要写成<code>1ll</code>；</p><h4 id="code-20">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> minm = <span class="number">1ll</span> &lt;&lt;<span class="number">32</span>,low;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        low = root-&gt;val;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> minm == <span class="number">1ll</span> &lt;&lt;<span class="number">32</span>?<span class="number">-1</span>:minm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ; </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; low &amp;&amp; root-&gt;val != minm)</span><br><span class="line">                minm = <span class="built_in">min</span>(minm, <span class="number">1ll</span> * root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层平均值"><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><h4 id="code-21">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode *&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode * temp = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum += temp-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="n-叉树的最大深度"><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h3><h4 id="code-22">code</h4><p>bfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;Node *&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> dep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            dep ++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;size; i++) &#123;</span><br><span class="line">                Node *p = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> child:p-&gt;children) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;children.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxm = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child:root-&gt;children) &#123;</span><br><span class="line">            maxm = <span class="built_in">max</span>(maxm, <span class="number">1</span> + <span class="built_in">maxDepth</span>(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-04.02.-最小高度树"><a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/">面试题 04.02. 最小高度树</a></h3><h4 id="code-23">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode * res;</span><br><span class="line">        <span class="keyword">if</span>(!nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">build</span>(res, <span class="number">0</span>, n - <span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(TreeNode * &amp;res, <span class="keyword">int</span> l, <span class="keyword">int</span> r, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">            <span class="built_in">build</span>(res-&gt;left, l, mid - <span class="number">1</span>, nums);</span><br><span class="line">            <span class="built_in">build</span>(res-&gt;right, mid + <span class="number">1</span>, r, nums);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树中的搜索"><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><h4 id="code-24">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode * l = <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">            TreeNode * r = <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">            <span class="keyword">if</span> (!l) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的范围和"><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h3><h4 id="code-25">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= high &amp;&amp; root-&gt;val &gt;= low) ans += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt;= low) ans += <span class="built_in">rangeSumBST</span>(root-&gt;left, low, high);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= high) ans += <span class="built_in">rangeSumBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最小深度"><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><h4 id="code-26">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode * l = root-&gt;left;</span><br><span class="line">        TreeNode * r = root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(!l &amp;&amp; !r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; r) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(l), <span class="built_in">minDepth</span>(r));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(l?l:r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="n叉树的后序遍历"><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N叉树的后序遍历</a></h3><h4 id="code-27">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child:root-&gt;children) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="叶子相似的树"><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></h3><h4 id="code-28">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sle[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root1,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root2,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(sle[<span class="number">0</span>] != sle[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            sle[i].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,i);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的所有路径"><a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>使用<code>to_string()</code>将数字转化为字符串，<code>(char)(number + '0')</code>这种方法只使用于一位正数；</p><h4 id="code-29">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">count</span>(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(TreeNode * root, string temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp + <span class="built_in">to_string</span>(root-&gt;val));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">count</span>(root-&gt;left, temp + <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">count</span>(root-&gt;right, temp + <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的坡度"><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">563. 二叉树的坡度</a></h3><h4 id="code-30">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">countval</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countval</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> vl = <span class="built_in">countval</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> vr = <span class="built_in">countval</span>(root-&gt;right);</span><br><span class="line">        ans += <span class="built_in">abs</span>(vl-vr);</span><br><span class="line">        <span class="keyword">return</span> vl + vr + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="另一个树的子树"><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></h3><p>写了一个比较好想的方法，官方题解放了kmp、树哈希之类的；</p><h4 id="code-31">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode *&gt;res;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s || !t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">find</span>(t, s);</span><br><span class="line">        TreeNode * st = t;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> x: res) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(st, x))</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s &amp;&amp; t || s &amp;&amp; !t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s &amp;&amp; !t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;val == t-&gt;val) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">check</span>(s-&gt;left, t-&gt;left) &amp;&amp; <span class="built_in">check</span>(s-&gt;right, t-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(TreeNode * s, TreeNode * t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s || !t) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;val == t-&gt;val)</span><br><span class="line">            res.<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="built_in">find</span>(s, t-&gt;left);</span><br><span class="line">        <span class="built_in">find</span>(s, t-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最近公共祖先"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><h4 id="code-32">code</h4><p>写了一个比较笨的方法，就是统计根节点到要查询的节点的路径，然后从根节点进行比较，找到第一个不同的父节点之前的父节点即为答案；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* sp[<span class="number">10004</span>];</span><br><span class="line">    TreeNode* sq[<span class="number">10004</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">findpath</span>(root, p, sp, &amp;i);</span><br><span class="line">        <span class="built_in">findpath</span>(root, q, sq, &amp;j);</span><br><span class="line">        TreeNode* pre = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i &amp;&amp; k &lt; j; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sp[k]-&gt;val == sq[k]-&gt;val) pre = sp[k];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findpath</span><span class="params">(TreeNode* root, TreeNode* f, TreeNode* s[], <span class="keyword">int</span> *n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        s[(*n)++] = root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == f-&gt;val)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">findpath</span>(root-&gt;left,f, s, n);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">findpath</span>(root-&gt;right, f, s, n);</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; ! r) &#123;</span><br><span class="line">            (*n)--;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是官方解，当发现<code>p</code>和<code>q</code>分别位于某个子树的两个分支里时，那么当前节点就是他们的最近公共祖先；</p><p>还一种方法是用<code>map</code>记录路径；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode * l = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode * r = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(!l) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span>(!r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;n叉的前序遍历&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/&quot;&gt;589. N叉的前序遍历&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;code&quot;&gt;code&lt;/h4&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;vector&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;title&quot;&gt;preorder&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node* root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (root == &lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(root-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root-&amp;gt;children.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;() == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; child:root-&amp;gt;children) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;preorder&lt;/span&gt;(child);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="https://chagelo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://chagelo.github.io/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
    
    <category term="leetcode" scheme="https://chagelo.github.io/tags/leetcode/"/>
    
    <category term="树" scheme="https://chagelo.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 动态规划</title>
    <link href="https://chagelo.github.io/2020/12/30/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://chagelo.github.io/2020/12/30/leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-12-30T05:07:28.000Z</published>
    <updated>2021-03-11T13:36:13.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="零钱兑换"><a href="https://leetcode-cn.com/problems/coin-change/">322.零钱兑换</a></h3><h4 id="code">code</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [<span class="number">10005</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i]:</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j - coins[i]] + <span class="number">1</span>, dp[j])</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="number">10005</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="最大子序和"><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h3><h4 id="题解">题解</h4><p>如果直接求最大子序和是不好求的，这里的想法是这样的，用一个变量保存序列和，如果子序列和为负，那么它很不好，就清空，并将当前数字赋给这个和，反之就累加当前值，这个和在整个过程中，是从0增大，然后可能会减小到0，最大子序和一定出现在这个过程中；</p><h4 id="code-1">code</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># nums[i]表示以第i个数字结尾最大和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i]= nums[i] + <span class="built_in">max</span>(nums[i-<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        maxm = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        temp = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">                temp += x</span><br><span class="line">            <span class="keyword">else</span> temp = x</span><br><span class="line">            maxm = <span class="built_in">max</span>(temp, maxm)</span><br><span class="line">        <span class="keyword">return</span> maxm</span><br></pre></td></tr></table></figure><h3 id="按摩师"><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/">17.16. 按摩师</a></h3><h4 id="code-2">code</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">massage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        A,B = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># A是选择当前数字，B是不选</span></span><br><span class="line">            A,B = B + nums[i], <span class="built_in">max</span>(B,A)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(A,B)</span><br></pre></td></tr></table></figure><h3 id="使用最小花费爬楼梯"><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h3><h4 id="code-3">code</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cost) == <span class="number">2</span>: <span class="keyword">return</span> <span class="built_in">max</span>(cost[<span class="number">0</span>],cost[<span class="number">1</span>])</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cost) + <span class="number">2</span>)]</span><br><span class="line">        count = <span class="built_in">len</span>(cost)</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, count):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i], dp[i - <span class="number">2</span>] + cost[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[count - <span class="number">1</span>], dp[count - <span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="一和零"><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h3><h4 id="code-4">code</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>], m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 二维约束01背包</span></span><br><span class="line">        zero,one = [],[]</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs:</span><br><span class="line">            zero.append(<span class="built_in">str</span>.count(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">            one.append(<span class="built_in">str</span>.count(<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m,zero[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n, one[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                        dp[j][k] = <span class="built_in">max</span>(dp[j - zero[i]][k - one[i]] + <span class="number">1</span>, dp[j][k])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><h4 id="题解-1">题解</h4><p>第一种做法比较简单，也比较好想到，<span class="math inline">\(dp[i]\)</span>表示第<span class="math inline">\(i\)</span>个数字结尾的序列最长长度；</p><p>第二种做法：用一个数组暂存最长上升子序列<span class="math inline">\(a\)</span>，每遍历到一个数字，用二分把这个数字查到<span class="math inline">\(a\)</span>里面；给定序列<code>[10,9,2,5,3,7,1]</code></p><p>当遍历到<span class="math inline">\(7\)</span>的时候，<span class="math inline">\(a\)</span>里面为<code>[2,3,7]</code>，当遍历到<span class="math inline">\(1\)</span>时候，<span class="math inline">\(1\)</span>插进去为<code>[1,3,7]</code>，这样并不会影响最长上升子序列的长度，并且，如果原序列中<span class="math inline">\(1\)</span>后面还有长度超过<span class="math inline">\(3\)</span>上升子序列，那么整个<span class="math inline">\(a\)</span>会被更新成更长的上升子序列；</p><h4 id="code-5">code</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[j]:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[i] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><h3 id="最长等差数列"><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence/">1027. 最长等差数列</a></h3><h4 id="题解-2">题解</h4><p>思路1：<span class="math inline">\(dp[i][k]\)</span>，表示以<span class="math inline">\(a[i]\)</span>结尾，公差为<span class="math inline">\(k\)</span>的最长等差子列长度 在这种情况下，考虑状态转移，仅需要枚举任意两元素<span class="math inline">\(i、j\)</span>，考虑<span class="math inline">\(j\)</span>到<span class="math inline">\(i\)</span>的状态转移；</p><p>思路2：<span class="math inline">\(dp[i][j]\)</span>，表示以<span class="math inline">\(a[j]、a[i]\)</span>作为最长等差子列结尾两元素（也就是公差是<span class="math inline">\(a[i] - a[j]\)</span>）的最长长度； 这种情况下，暴力的想，可以枚举<span class="math inline">\(k\)</span>，使<span class="math inline">\(k、j、i\)</span>三个元素成为一个等差数列，然后考虑状态转移，但这样复杂度很高，然而这个过程是贪心的，即这个<span class="math inline">\(k\)</span>越大越好（但需要小于<span class="math inline">\(j\)</span>），我们可以这样做：每一次枚举<span class="math inline">\(j\)</span>结束后更新answer，并且<code>mp[a[j]] = j</code></p><h4 id="code-6">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[<span class="number">2005</span>][<span class="number">20010</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            d[i][<span class="number">10000</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> diff = A[i] - A[j] + <span class="number">10000</span>;</span><br><span class="line">                <span class="keyword">int</span>&amp; r = d[i][diff];</span><br><span class="line">                r = <span class="built_in">max</span>(r,<span class="built_in">max</span>(<span class="number">2</span>,d[j][diff]+<span class="number">1</span>));</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> idx[<span class="number">10010</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">        <span class="built_in">memset</span>(idx,<span class="number">0xcf</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(idx));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            d[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">int</span>&amp; r=d[j][i];</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    r = <span class="built_in">max</span>(r,<span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = <span class="number">2</span> * A[j] - A[i];</span><br><span class="line">                    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || idx[x] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        r = <span class="built_in">max</span>(r,<span class="number">2</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        r = <span class="built_in">max</span>(r,d[idx[x]][j]+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,r);</span><br><span class="line">                idx[A[j]] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长湍流子数组"><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a></h3><h4 id="code-7">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>])sum[<span class="number">0</span>]++, sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; arr[i - <span class="number">1</span>])sum[<span class="number">1</span>]++, sum[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">else</span> sum[<span class="number">0</span>] = sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(i % <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[i - <span class="number">1</span>])sum[<span class="number">0</span>]++,sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])sum[<span class="number">1</span>]++,sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> sum[<span class="number">0</span>] = sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,<span class="built_in">max</span>(sum[<span class="number">0</span>], sum[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="k-站中转内最便宜的航班"><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班</a></h3><h4 id="code-8">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">103</span>][<span class="number">103</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f3f3f3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: flights) </span><br><span class="line">            <span class="keyword">if</span> (x[<span class="number">0</span>] == src)</span><br><span class="line">                dp[x[<span class="number">1</span>]][<span class="number">0</span>] = x[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; i++)</span><br><span class="line">            dp[src][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; k++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: flights)</span><br><span class="line">                <span class="keyword">if</span> (dp[x[<span class="number">0</span>]][k - <span class="number">1</span>] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">                    dp[x[<span class="number">1</span>]][k] = <span class="built_in">min</span>(dp[x[<span class="number">1</span>]][k], dp[x[<span class="number">0</span>]][k - <span class="number">1</span>] + x[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[dst][K] == <span class="number">0x3f3f3f3f</span>?<span class="number">-1</span>:dp[dst][K];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="统计字典序元音字符串的数目"><a href="https://leetcode-cn.com/problems/count-sorted-vowel-strings/">1641. 统计字典序元音字符串的数目</a></h3><h4 id="code-9">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">                sum += dp[j];</span><br><span class="line">                dp[j] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="整数拆分"><a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a></h3><h4 id="题解-3">题解</h4><p><span class="math inline">\(dp[i]\)</span>表示对于整数<span class="math inline">\(i\)</span>拆分成若干整数之后的最大乘积，那么显然的，<span class="math inline">\(dp[i] = max(dp[i],dp[i - k] * k)(1\leq k\leq i - 1)\)</span>；但是这不包括所有情况，<span class="math inline">\(dp[6] = dp[3] * 3 = 6\)</span>，而<span class="math inline">\(dp[6] = 3 * (6 - 3) = 9\)</span>更大；即<span class="math inline">\(dp[i] = max(dp[i], j * (i - j))\)</span>；</p><h4 id="code-10">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">60</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j * (i - j), dp[j] * (i - j)));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="环绕字符串中唯一的子字符串"><a href="https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a></h3><h4 id="题解-4">题解</h4><p>这题第一次做，把自己给绕进去了，甚至没读懂题目；</p><p>题目让我们求<span class="math inline">\(p\)</span>中有多少个种连续的字符串，连续即题目中所谓的连续；</p><p>如果不考虑多少种，仅仅问多少个，这就相当于问有多少个连续子区间，这个比较好求；但这里要求不重复；</p><p>定义<span class="math inline">\(dp[i]\)</span>，表示以字符<span class="math inline">\(i\)</span>结尾的最大连续子串，这样就可以去除重复；比如对于<code>abcbc</code>，当遍历到第一个<code>c</code>，<span class="math inline">\(dp[&#39;c&#39;] = 6\)</span>，对于后面的<code>bc</code>，显然他已经包含在<code>dp['c']=6</code>的情况之内了；还可以尝试模拟这个字符串的情况：<code>abczab</code>；</p><ol type="1"><li>这个题解里的图的变化情况解释的很好：https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/solution/dong-tai-gui-hua-c-by-lcoder55455-y3px/</li><li>这篇博客对于滑动窗口写的很好：https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/</li></ol><h4 id="code-11">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="string">&quot;&quot;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">30</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        dp[p[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] == p[i - <span class="number">1</span>] + <span class="number">1</span> || p[i - <span class="number">1</span>] == p[i] + <span class="number">25</span>)</span><br><span class="line">                sum ++;</span><br><span class="line">            <span class="keyword">else</span> sum = <span class="number">1</span>;</span><br><span class="line">            dp[p[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">max</span>(dp[p[i] - <span class="string">&#x27;a&#x27;</span>], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="计算各个位数不同的数字个数"><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">357. 计算各个位数不同的数字个数</a></h3><p>非常多种写法</p><h3 id="矩阵区域和"><a href="https://leetcode-cn.com/problems/matrix-block-sum/">1314. 矩阵区域和</a></h3><h3 id="只有两个键的键盘"><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></h3><h3 id="填充书架"><a href="https://leetcode-cn.com/problems/filling-bookcase-shelves/">1105. 填充书架</a></h3><h4 id="题解-5">题解</h4><p><span class="math inline">\(dp[i]\)</span>表示<span class="math inline">\(i\)</span>本书的最小高度，也就是以第<span class="math inline">\(i\)</span>本书作为最后一层最后一本书，达到的最小高度，我们已经知道前面<span class="math inline">\(1\)</span>到<span class="math inline">\(i-1\)</span>本书能达到的最小高度，只要枚举最后一层的书，最后一层一定是包含<span class="math inline">\(i\)</span>之前的若干本，并且厚度有上限，我们就可以从中更新出最小高度；</p><h4 id="code-12">code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minHeightShelves</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; books, <span class="keyword">int</span> shelf_width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = books.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">1000</span>*<span class="number">1000</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> tmpWidth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j) &#123;</span><br><span class="line">                tmpWidth += books[j - <span class="number">1</span>][<span class="number">0</span>];                </span><br><span class="line">                <span class="keyword">if</span>(tmpWidth &gt; shelf_width) <span class="keyword">break</span>;</span><br><span class="line">                h = <span class="built_in">max</span>(h, books[j - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[j<span class="number">-1</span>] + h);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;零钱兑换&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/&quot;&gt;322.零钱兑换&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;code&quot;&gt;code&lt;/h4&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;coinChange&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, coins: &lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;], amount: &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; amount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count = &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(coins)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp = [&lt;span class=&quot;number&quot;&gt;10005&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(amount + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, count):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(amount + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; j &amp;gt;= coins[i]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    dp[j] = &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;(dp[j - coins[i]] + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, dp[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dp[amount] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; dp[amount] != &lt;span class=&quot;number&quot;&gt;10005&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="https://chagelo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="dp" scheme="https://chagelo.github.io/categories/%E7%AE%97%E6%B3%95/dp/"/>
    
    
    <category term="dp" scheme="https://chagelo.github.io/tags/dp/"/>
    
    <category term="leetcode" scheme="https://chagelo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[ABC 172]</title>
    <link href="https://chagelo.github.io/2020/07/10/ABC-172/"/>
    <id>https://chagelo.github.io/2020/07/10/ABC-172/</id>
    <published>2020-07-10T10:35:23.000Z</published>
    <updated>2021-03-20T07:07:19.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接">链接</h2><p><a href="https://atcoder.jp/contests/abc172/tasks"><span class="math inline">\(\text{ABC172}\)</span></a></p><h2 id="c">C</h2><h3 id="题意">题意</h3><p>  给两个<span class="math inline">\(Stack\)</span>，<span class="math inline">\(A、B\)</span>。<span class="math inline">\(A、B\)</span>中分别有<span class="math inline">\(N、M\)</span>个物品，每个物品分别有一个价值，<span class="math inline">\(A[i]、B[j]\)</span>。现在给定一个<span class="math inline">\(K\)</span>，现在需要从A、B中将物品从栈拿出来（每次从最上面拿），一次拿一个，要求所拿出来的物品的价值的总价值不大于<span class="math inline">\(K\)</span>，求最多可以拿出来多少个物品；</p><p>  输入格式：第一行<span class="math inline">\(N、M、K\)</span>，第二行<span class="math inline">\(N\)</span>个数表示序列<span class="math inline">\(A\)</span>，第三行<span class="math inline">\(M\)</span>个数表示序列<span class="math inline">\(B\)</span>。</p><p>  数据范围：<span class="math inline">\(1\leq N，M\leq 200000，1\leq K\leq 10^9，1\leq A_i,B_i\leq 10^9\)</span>.</p><p>  输出格式：输出一个整数，代表最多可以拿出来的物品的个数。</p><span id="more"></span><h3 id="分析">分析</h3><p>  即求满足<span class="math inline">\(sumA[i]+sumB[j]\leq K\)</span>的<span class="math inline">\(\max(i+j)\)</span>，那么我们枚举<span class="math inline">\(i\)</span>（<span class="math inline">\(j\)</span>也可以），对每个<span class="math inline">\(i\)</span>，找到二分找到满足<span class="math inline">\(sumA[i]+sumB[j]\leq K\)</span>的最大的<span class="math inline">\(j\)</span>，然后取<span class="math inline">\(\max(i+j)\)</span>即可；</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a, b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll k;</span><br><span class="line"></span><br><span class="line">ll s1[maxn], s2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">-1</span>, r = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt;<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (x + s2[mid] &lt;= k)</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; t, s1[i] = s1[i - <span class="number">1</span>] + t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        cin &gt;&gt; t, s2[j] = s2[j - <span class="number">1</span>] + t;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, maxm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] &gt; k) <span class="keyword">break</span>;</span><br><span class="line">        maxm = i;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="built_in">find</span>(s1[i]);</span><br><span class="line">        maxm += pos;</span><br><span class="line">        res = <span class="built_in">max</span>(maxm, res);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d">D</h2><h3 id="题意-1">题意</h3><p>  定义<span class="math inline">\(f(x)\)</span>为<span class="math inline">\(x\)</span>的因子的个数，如<span class="math inline">\(f(4)=3\)</span>，现在，给定一个<span class="math inline">\(N\)</span>需要求<span class="math inline">\(\sum_{x=1}^{N}x\times f(x)\)</span>;</p><p>  数据范围：<span class="math inline">\(1\leq N \leq10^7\)</span></p><h3 id="分析-1">分析</h3><p>  对于第<span class="math inline">\(i\)</span>个数来说，它对<span class="math inline">\(\sum_{x=1}^{N}x\times f(x)\)</span>的贡献为<span class="math inline">\(\frac{t*(t+1)*i}{2}\)</span>，其中<span class="math inline">\(t=N/i\)</span>；</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a, b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line">ll res;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = n / i;</span><br><span class="line">        res += <span class="number">1ll</span> * t * (t + <span class="number">1</span>) / <span class="number">2</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;链接&quot;&gt;链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc172/tasks&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{ABC172}\)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;c&quot;&gt;C&lt;/h2&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;  给两个&lt;span class=&quot;math inline&quot;&gt;\(Stack\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(A、B\)&lt;/span&gt;。&lt;span class=&quot;math inline&quot;&gt;\(A、B\)&lt;/span&gt;中分别有&lt;span class=&quot;math inline&quot;&gt;\(N、M\)&lt;/span&gt;个物品，每个物品分别有一个价值，&lt;span class=&quot;math inline&quot;&gt;\(A[i]、B[j]\)&lt;/span&gt;。现在给定一个&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;，现在需要从A、B中将物品从栈拿出来（每次从最上面拿），一次拿一个，要求所拿出来的物品的价值的总价值不大于&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;，求最多可以拿出来多少个物品；&lt;/p&gt;
&lt;p&gt;  输入格式：第一行&lt;span class=&quot;math inline&quot;&gt;\(N、M、K\)&lt;/span&gt;，第二行&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个数表示序列&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，第三行&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;个数表示序列&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;  数据范围：&lt;span class=&quot;math inline&quot;&gt;\(1\leq N，M\leq 200000，1\leq K\leq 10^9，1\leq A_i,B_i\leq 10^9\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;  输出格式：输出一个整数，代表最多可以拿出来的物品的个数。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://chagelo.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="二分" scheme="https://chagelo.github.io/categories/%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%88%86/"/>
    
    
    <category term="二分" scheme="https://chagelo.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="题解" scheme="https://chagelo.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>为什么要学习</title>
    <link href="https://chagelo.github.io/2020/06/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://chagelo.github.io/2020/06/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-06T11:07:37.000Z</published>
    <updated>2020-06-06T11:17:55.913Z</updated>
    
    <content type="html"><![CDATA[<center><strong>我们为什么要学习</strong></center><p>  我们为什么要学习，相信这是每个人从幼儿园开始就纠缠一生的问题；有的人觉得不需要学习，所以辍学了；有的人想明白了，所以走上了学霸的道路；然而更多的人没想明白，但也没办法，只是被迫学习，效果一般，而且还学的很痛苦，相信我们都遇见过这些人；说到为什么要学习这个问题，相信不同的人会给出不同的答案；第一种人，由于父母的要求不得不被迫学习；第二年种，想要上学的目的是，拥有更好的学历；第三种则是因为兴趣而学习，想要学习到更有趣的知识，想要见识到更美丽、令人惊叹的景色；对于我们每个人来说，我们都拥有一个属于自己的答案；</p><span id="more"></span><p>  小时候，班主任经常会在讲台上与我们声嘶力竭地互动：“你们学习是给我学的吗？”“不是！”“是给你爸妈学的吗”“不是！”“那是给谁学的？”“自己！”天长日久，成了一套固定模式，记住了“学习”是为了自己，但并不知道为了自己的什么。后来懂点事了，母亲经常教导我：“好好学习，有了出息，才不被人欺负。”开始也听不进去，说的多了，也就记住了学习是为了有出息，为了出人头地。</p><p>  在我读大学之前，初中、高中，我一直是处于一种浑浑噩噩的状态，当时的我只有对数学这一门学科上心，别的科目大概就是不管不顾的态度；来到了大学，因为一次转机，来到计算机专业；在这里，我见识到了自己喜欢的东西，见识到了很优秀的同学，结识了优秀而有趣、幽默的一些同学、学长，见识到了更美丽的知识，找到了属于自己的美丽的景色；在我看来，真正意义上的学习，是会开始自己去思考任何一件事情，从而变得思想上的独立，潜移默化地让自己拥有独立的人格品质和自己的一套行为作风，在那一霎那，我们就开始了蜕变，整个世界在我们眼中就变得不一样了；我们对任何事情都保持一种轻松的态度；我现在认为我是属于那第三类人，我也希望我自己能够一直保持这样一种态度；</p><p>  首先什么是学习，我认为，通俗意义上的学习就是通过各种渠道方式认识、了解到我们之前不熟悉或不知道的知识，依次来能够使我们的身心素质得到提高、使我们更加强大；学习的渠道有很多；上课、看书、网课、浏览博客等等都是学习；现在社会学习的方式太多了； 学习有什么用呢？</p><p>  首先，最浅显的，我们通过学习了解了之前所不曾了解的知识，也就是掌握了知识点，可以拿RPG游戏做例子，学习对我们来说就是打怪练级的过程，知识就是装备，我们的装备越全我们当然就越厉害、越强大；</p><p>  之后，我们通过这些知识，可以实现之前没有掌握这些知识之前做不到的思考，或者修正我们之前的错误的思考，从而得到成长；最后，我们通过自己的思考结果，能更好的认识这个世界，以此引导我们的行为，根据我们的需要更好的改造世界。 有个前辈这样和我说过：“我的人生三大价值观依次是自由、独立思考、终身学习，但实际上践行的顺序完全是相反的，只有通过终身学习我才能做到独立思考，只有做到独立思考我才能实现某种意义上的自由。”</p><p>  当我们刚刚呱呱坠地之日起，就用手去抓、摸周围的事物，去感知事物的硬度、温度。尽管那时我们的眼睛尚未睁开，但我们开始了最原始的，也是速度最快的，内容最丰富的学习。我想，假如我们没有这些简单的学习方式，那么人类永远就只能停留在婴孩时代，这是一个无法想象也不可能去想象的场景。这样的话，人类会脆弱得连一只苍蝇、一只蚂蚁都不可能打败。学习是人得一种责任。</p><p>  学习还是一种权利，人还有获得自我发展，实现人生价值的权力。有人会说这根本不是权力。假如这样认为的话，我们就完全失去了作为一个生命体的存在的意义。</p><p>  学习还是人的一种基本需要。这种需要就像吃饭、穿衣、喝水一样，是人的一种生存的必需，这个是显然的；当然，学习的方式是多种多样的，层次不同的，也有高尚和低劣的学习。如孝悌的学习、诚信的学习、学习方法的学习、知识技能的学习、法纪法规的学习等等。否则，知识匮乏、法纪观念淡薄、做事不计后果，必然要出大问题。可以这样说，如果没有诚信、没有知识技能，没有礼仪、规范、准则、品行的人，我们很难想象会是一个怎样的人；</p><p>  如果你曾经有过最终习得某种技能的经验，就知道在学会的那一瞬间，不用多说，整个世界在你眼中都不一样了。或者说，因为你有能力做更多的事情，你就不再存在于原来的世界，因为你所学会的技能，你已经拥有另一个完全不同的世界；每次我学会了一个新知识，就感觉自己重生了一次，如此看来，原本可以有很多被子的，只不过大多数人放弃了而已。</p><p>  我们常常能听见有些人老是宣扬学习无用论，然而在我看来这不过是失败者的借口而已；</p><p>  在古代，古代人成为有钱人的最有效的途径是什么？是通过科举考试；在那个两耳不闻窗外事，一心只读圣贤书的年代，对于平民老百姓来说，读书是唯一的出路，是唯一的可以让你从一个阶层迈到另一个阶层，并收获大量财富的追梦之路。那么要考上状元，需要读多少书呢？寒窗十载，《三字经》、《百家姓》、《千家诗》、《四书五经》、《文心雕龙》、《二十四史》、《古文观止》等等数不胜数，通读这些书，你才能作诗，才能写八股文，才能在考场上文思如涌泉。</p><p>  通过学习，我们可以获得身心的解放，获得思想的解放，和精神上的解放；每当我们真正投入学习时，那种充实、愉悦，那种学习到新知识后的充实，那种难以言表的心情，我想都是任何人包括我自己的最宝贵的精神财富。</p>]]></content>
    
    
    <summary type="html">&lt;center&gt;
&lt;strong&gt;我们为什么要学习&lt;/strong&gt;
&lt;/center&gt;
&lt;p&gt;  我们为什么要学习，相信这是每个人从幼儿园开始就纠缠一生的问题；有的人觉得不需要学习，所以辍学了；有的人想明白了，所以走上了学霸的道路；然而更多的人没想明白，但也没办法，只是被迫学习，效果一般，而且还学的很痛苦，相信我们都遇见过这些人；说到为什么要学习这个问题，相信不同的人会给出不同的答案；第一种人，由于父母的要求不得不被迫学习；第二年种，想要上学的目的是，拥有更好的学历；第三种则是因为兴趣而学习，想要学习到更有趣的知识，想要见识到更美丽、令人惊叹的景色；对于我们每个人来说，我们都拥有一个属于自己的答案；&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://chagelo.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://chagelo.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>JS入门</title>
    <link href="https://chagelo.github.io/2019/12/24/JS%E5%85%A5%E9%97%A8/"/>
    <id>https://chagelo.github.io/2019/12/24/JS%E5%85%A5%E9%97%A8/</id>
    <published>2019-12-24T05:36:08.000Z</published>
    <updated>2019-12-24T05:38:11.223Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义一个数组">定义一个数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr_1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> arr_2 = [<span class="string">&#x27;abds&#x27;</span>,<span class="number">12</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(arra_1); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><h4 id="注释">注释</h4><p>  单行注释用<code>//</code>，多行注释以<code>/*</code>开始，以<code>*/</code>结尾；</p><h4 id="闭包">闭包</h4><p>  使用闭包可以从内部函数访问外部函数作用域。</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner1 = outer();</span><br><span class="line">inner1(); <span class="comment">// 11</span></span><br><span class="line">inner1(); <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">var</span> inner2 = outer();</span><br><span class="line">inner2(); <span class="comment">// 11</span></span><br><span class="line">inner2(); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h4 id="匿名函数">匿名函数</h4><p>  可以使用匿名函数创建命名空间，只要把自己的代码写在这个特殊函数内，外部就不能访问，还可以减少全局变量的使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);&#125;;</span><br><span class="line">f(); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 下面即是定义一个匿名函数，并且立即执行(IIFE，即立即调用的函数表达式)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y);  </span><br><span class="line">&#125;)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//下面的写法可以上函数立即执行，还可以将前面加上其他符号</span></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line"><span class="comment">//···</span></span><br></pre></td></tr></table></figure><h4 id="iife">IIFE</h4><p>  IIFE，即立即调用的函数表达式，仅仅是一个表达式，不能像函数一样，把他赋给一个变量；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// console.log(i);</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(m);</span><br><span class="line">     &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是dom">什么是DOM</h4><p>  文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。</p><p>W3C DOM 标准被分为 3 个不同的部分：</p><ul><li>Core DOM - 所有文档类型的标准模型</li><li>XML DOM - XML 文档的标准模型</li><li>HTML DOM - HTML 文档的标准模型</li></ul><p>HTML DOM是关于如何获取、更改、添加或删除HTML元素的标准。它定义了作为对象的HTML元素，所有HTML元素的属性，访问所有HTML元素的方法，所有HTML元素的事件；</p><p>HTML DOM模型被结构化为对象树；通过这个对象，js能够对HTML进行操作；</p><ul><li>js能够改变页面中的所有HTML元素</li><li>js能改变页面中所有HTML属性</li><li>js能改变页面中的所有css样式</li></ul><p>等等。。</p><h4 id="dom">DOM</h4><p>  DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分，这使得JavaScript操作HTML，不是在操作字符串，而是在操作节点，极大的降低了变成难度。</p><h5 id="得到元素">得到元素</h5><ol type="1"><li>document.getElementById("intro")，查找id="intro"的元素，找到则以对象形式返回该元素，未找到则返回null，id是区别大小写的，IE6、IE7、IE8中是不区分大小写的。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span> = <span class="string">&quot;box&quot;</span>&gt;</span>ppp<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(box); <span class="comment">// &lt;p id = &quot;box&quot;&gt;ppp&lt;/p&gt;</span></span></span><br><span class="line"><span class="javascript">            box.style.background = <span class="string">&#x27;red&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>document.getElementsByTagName("p")，这个方法返回的是一个叫做HTMLCollection的东西，类似数组，里面存的是所有p标签，可以通过下标访问具体的某个标签，如果没有p标签，则返回一个空的HTMLCollection；</li></ol><h5 id="更改html属性">更改HTML属性</h5><ol type="1"><li><p>直接通过<code>.</code>来调用指定标签的属性，通过赋值的形式进行更改；另外class这个属性，要换成className，因为class是JavaScript的保留字，还有for要写成htmlFor，rowspan写成rowSpan，colspan写成colSpan;</p></li><li><p>setAttribute(string s1, string s2)，设置s1的属性值为s2，如果不存在s1属性，就添加一个属性值为s2的s1属性。</p></li><li><p>getAttribute(string name)，获取name属性的属性值；</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span> = <span class="string">&quot;box&quot;</span>&gt;</span>ppp<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span></span><br><span class="line"><span class="javascript">            box.id = <span class="string">&quot;box1&quot;</span>;</span></span><br><span class="line"><span class="javascript">            box.innerText = <span class="string">&quot;123&quot;</span>;</span></span><br><span class="line"><span class="javascript">            box.setAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;box2&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(box.getAttribute(<span class="string">&quot;id&quot;</span>)); <span class="comment">// box2</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(box.getAttribute(<span class="string">&quot;p&quot;</span>)); <span class="comment">// 123</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(box.getAttribute(<span class="string">&quot;id&quot;</span>)); <span class="comment">//box2</span></span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，使用<code>.</code>或使用<code>getAttribute</code>来获取属性值是有区别的，前者是不能获取自定义属性的，后者是可以的，并且<code>.</code>获取的属性的属性值是object的，而<code>getAttribute</code>获取的属性属性值是string类型的。</p><h5 id="操作元素样式">操作元素样式</h5><p>  比较简单就不说了。</p><h5 id="事件监听">事件监听</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">                <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">id</span>=<span class="string">&quot;idbox&quot;</span>&gt;</span>div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">&quot;idbox&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(box.click);</span></span><br><span class="line"><span class="javascript">            box.onclick = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  时间的类型有onclick（单击）、onmouseover（鼠标进入）、onmouseout（鼠标离开）、ondblclick（双击）、onfocus（得到焦点）、onblur（失去焦点）、onmousedown（鼠标按下）、onmouseup（鼠标按键抬起）。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction">DOM</a></p><h5 id="批量监听">批量监听</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p_arra = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; p_arra.length; i++) &#123;</span><br><span class="line">    <span class="comment">//IIFE</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">        p_arra[m].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(m);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p_arra = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; p_arra.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 绑定自定义属性</span></span><br><span class="line">    p_arra[i].idx = i;</span><br><span class="line">    p_arra[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.idx);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;定义一个数组&quot;&gt;定义一个数组&lt;/h4&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr_1 = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr_2 = [&lt;span class=&quot;string&quot;&gt;&amp;#x27;abds&amp;#x27;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&amp;#x27;hello&amp;#x27;&lt;/span&gt;);&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arra_1); &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;注释&quot;&gt;注释&lt;/h4&gt;
&lt;p&gt;  单行注释用&lt;code&gt;//&lt;/code&gt;，多行注释以&lt;code&gt;/*&lt;/code&gt;开始，以&lt;code&gt;*/&lt;/code&gt;结尾；&lt;/p&gt;
&lt;h4 id=&quot;闭包&quot;&gt;闭包&lt;/h4&gt;
&lt;p&gt;  使用闭包可以从内部函数访问外部函数作用域。&lt;/p&gt;</summary>
    
    
    
    <category term="js" scheme="https://chagelo.github.io/categories/js/"/>
    
    <category term="js基础" scheme="https://chagelo.github.io/categories/js/js%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="js" scheme="https://chagelo.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ECB模式RSA的Java简单实现中遇到的问题</title>
    <link href="https://chagelo.github.io/2019/12/21/ECB%E6%A8%A1%E5%BC%8FRSA%E7%9A%84Java%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://chagelo.github.io/2019/12/21/ECB%E6%A8%A1%E5%BC%8FRSA%E7%9A%84Java%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-12-21T10:14:54.000Z</published>
    <updated>2019-12-24T09:11:11.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="连续使用一个字节数组读取文件">连续使用一个字节数组读取文件</h3><p>  在使用java的数组来实现连续读取数据的时候，遇到这样一个问题。</p><p>  我通过一个8字节数组来通过<code>FileOutputStream.read()</code>读取文件中的数据，所以我每次最多读8个字节，我文件中的数据如下，总共47个字符也就是47个字节，所以需要读6次；</p><blockquote><p>dshakjdhjksahklfdahkjhkjf hdljksahkfjlkjhadskjh</p></blockquote><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(file);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">byte</span> [] word = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((count = fis.read(word)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> s : word) &#123;</span><br><span class="line">                num ++;</span><br><span class="line">                System.out.print(num +<span class="string">&quot;: &quot;</span> + (<span class="keyword">char</span>)s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当我每读一次就把当前读到数组里的数据输出时，我发现数据与我文件中的不匹配。读取的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1: d 2: s 3: h 4: a 5: k 6: j 7: d 8: h</span><br><span class="line">9: j 10: k 11: s 12: a 13: h 14: k 15: l 16: f</span><br><span class="line">17: d 18: a 19: h 20: k 21: j 22: h 23: k 24: j</span><br><span class="line">25: f 26:   27: h 28: d 29: l 30: j 31: k 32: s</span><br><span class="line">33: a 34: h 35: k 36: f 37: j 38: l 39: k 40: j</span><br><span class="line">41: h 42: a 43: d 44: s 45: k 46: j 47: h 48: j</span><br></pre></td></tr></table></figure><p>  我们可以看到输出了48个字节多输出了一个字节，思考了一下我们可以想到，当我们最后一次读取文件数据时，如果这时候我们可以读取的数据已经不足8个字节，那么会怎么样呢，那么我们可以想到这最后一个字节可能来自上次8个字节的最后一个字节即第40个字节，每次使用<code>FileInputStream.read()</code>去读取数据，当前读取的数据都会把之前读取的数据给覆盖掉。所以我们每次读取之后，都要先把byte数组清空之后再进行下次读取；可以使用<code>java.util.Arrays.fill()</code>来实现；</p><h3 id="一个字节的表示">一个字节的表示</h3><p>  首先对于一个字节来说，表示有符号数时，范围是<code>-128~127</code>，其中<code>-128</code>的表示为<code>10000000</code>；正数为原码形式存在，负数为补码形式存在；比如对于一个字节来说，如果向计算机写入<code>-1</code>，它是一个有符号的负数，所以计算机会计算它的补码，从而转换为<code>11111111</code>；而对于<code>128~255</code>之间的数，计算机会自动视其为无符号数，那就以无符号原码表示，如<code>0xff</code>即255，就是<code>11111111</code>；</p><p>  所以有时候，我们就会遇到，255和-1都表示为<code>11111111</code>的情况；</p><h3 id="biginteger.tobytearray怎么实现的">BigInteger.toByteArray()怎么实现的</h3><p>  在网上找了一个说的比较好的解答，也有了自己的理解。</p><p>  下面是一个int的编码实例，其中需要注意二进制的4位表示一个十六进制数字，负数二进制开始为1，正数开始于0；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-2147483648 is encoded as 1000 0000 0000 0000 0000 0000 0000 0000 or 0x80000000.</span><br><span class="line">        -16 is encoded as 1111 1111 1111 1111 1111 1111 1111 0000 or 0xfffffff0.</span><br><span class="line">         -2 is encoded as 1111 1111 1111 1111 1111 1111 1111 1110 or 0xfffffffe.</span><br><span class="line">         -1 is encoded as 1111 1111 1111 1111 1111 1111 1111 1111 or 0xffffffff.</span><br><span class="line">          0 is encoded as 0000 0000 0000 0000 0000 0000 0000 0000 or 0x00000000.</span><br><span class="line">          1 is encoded as 0000 0000 0000 0000 0000 0000 0000 0001 or 0x00000001.</span><br><span class="line">         16 is encoded as 0000 0000 0000 0000 0000 0000 0001 0000 or 0x00000010.</span><br><span class="line"> 2147483647 is encoded as 0111 1111 1111 1111 1111 1111 1111 1111 or 0x7fffffff.</span><br></pre></td></tr></table></figure><p>  java只是把，每个8位块中现有的位拷贝到目标数组中的问题。一个字节即是一个8位的块.</p><p>  我们将一个BigInteger转换为二进制补码，我们想要的只是它的后面的有效的位，而不包含前面的无数的前导0和前导1；之后每8位的块即是一个字节；</p><p>  下面用数组里的十六进制来表示BigInteger；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                   0 [0x00000000]</span><br><span class="line">          2147483647 [0x7fffffff]</span><br><span class="line">          2147483648 [0x00000000, 0x80000000]</span><br><span class="line">          4294967296 [0x00000001, 0x00000000]</span><br><span class="line">          8589934592 [0x00000002, 0x00000000]</span><br><span class="line">     281474976710655 [0x0000ffff, 0xffffffff]</span><br><span class="line">     281474976710656 [0x00010000, 0x00000000]</span><br><span class="line">18446744073709551616 [0x00000001, 0x00000000, 0x00000000]</span><br><span class="line">    -281474976710656 [0xffff0000, 0x00000000]</span><br></pre></td></tr></table></figure><p>  之后分割、拿出其中有效的byte，即以每八位分割一次；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8589934592 [0x00 00 00 02, 0x00 00 00 00]</span><br><span class="line">bytes:     [           02,   00,00,00,00]</span><br></pre></td></tr></table></figure><ol type="1"><li>前面的三个00都可以被忽略，因为第一个有效数字之前有25个0；</li><li>然后将这些二进制位拷贝到字节中即可。</li></ol><p>对于官方的文档，其中有这样一句话，toByteArray()这个方法返回一个数组，这个数组包含可以代表这个BigInteger最小数量的字节，其中包含至少一个符号位。</p><p>符号位是什么意思呢。对于<code>-128~127</code>之间的数组，我们都可以用一个字节来表示，而对于<code>128~255</code>之间的数呢，比如255与-1，虽然二进制表示相同，但他们终究是不同的，所以这个方法考虑到这个问题，对于255就额外加了一个0x00表示符号位（如果第一个字节的大小大于0x7f，就需要在最前面加上一个0x00）；或者可以这样想，对于有符号数来说，<code>128~255</code>之间的数，一个字节是表示不了的，所以采用两个字节来表示，只不过最左边的那个字节是0x00；比如对于下面的两个byte数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">255 [0x00, 0xff]</span><br><span class="line">-1  [    , 0xff]</span><br></pre></td></tr></table></figure><p><strong>这个问题需要特别注意</strong>；</p><h3 id="byte数组转biginteger">byte数组转BigInteger</h3><p>  BigInteger有这样一个构造函数：<code>public BigInteger(byte[] val)</code>，它的参数是byte数组；对于<code>[0x00,0xff]</code>得到的BigInteger的到的结果是255，对于<code>[0xff]</code>的结果是-1；</p><p>  BigInteger还有这样一个构造函数：<code>public BigInteger(int signum,byte[] magnitude)</code>，其中多加了一个signum参数代表你的BigInteger的正负，为-1代表负数，为1代表整数，为0代表byte数组表示的数一定是0（即这个byte数组仅包括字节0x00），如果byte数组表示的数不为0，会报错。</p><p>  实践后发现，可能是这样的，如果signum为0，则在byte数组最前面加上一个0x00，然后反转上面toByteArray()的操作，得到最后的结果，如果signum为1，前面计算的结果上加上一个负号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] arr1 = &#123;<span class="number">0x00</span>&#125;;</span><br><span class="line">        <span class="keyword">byte</span> [] arr2 = &#123;<span class="number">0x00</span>,(<span class="keyword">byte</span>)<span class="number">0xff</span>&#125;;</span><br><span class="line">        <span class="keyword">byte</span> [] arr3 = &#123;(<span class="keyword">byte</span>)<span class="number">0xff</span>&#125;;</span><br><span class="line">        <span class="keyword">byte</span> [] arr4 = &#123;-<span class="number">1</span>,(<span class="keyword">byte</span>)<span class="number">0xff</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(arr4));   <span class="comment">//-32513</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>,arr4)); <span class="comment">//33023</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(-<span class="number">1</span>,arr4));<span class="comment">//-33023</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(-<span class="number">1</span>,arr1));<span class="comment">//0</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>,arr2)); <span class="comment">//255</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(-<span class="number">1</span>,arr2));<span class="comment">//-255</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>,arr3)); <span class="comment">//255</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(-<span class="number">1</span>,arr3));<span class="comment">//-255</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;连续使用一个字节数组读取文件&quot;&gt;连续使用一个字节数组读取文件&lt;/h3&gt;
&lt;p&gt;  在使用java的数组来实现连续读取数据的时候，遇到这样一个问题。&lt;/p&gt;
&lt;p&gt;  我通过一个8字节数组来通过&lt;code&gt;FileOutputStream.read()&lt;/code&gt;读取文件中的数据，所以我每次最多读8个字节，我文件中的数据如下，总共47个字符也就是47个字节，所以需要读6次；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dshakjdhjksahklfdahkjhkjf hdljksahkfjlkjhadskjh&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java" scheme="https://chagelo.github.io/categories/java/"/>
    
    <category term="java随笔" scheme="https://chagelo.github.io/categories/java/java%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="java" scheme="https://chagelo.github.io/tags/java/"/>
    
    <category term="java随笔" scheme="https://chagelo.github.io/tags/java%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
